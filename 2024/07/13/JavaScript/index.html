<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>JavaScript | 晚风的喵喵屋吖</title><meta name="author" content="晚风温柔苍生"><meta name="copyright" content="晚风温柔苍生"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="JavaScript是一种函数优先特性的轻量级、解释型或者说即时编译型的编程语言。JavaScript 是网页交互的核心，通过本课程，您将学会如何运用 JavaScript 实现动态效果和用户交互。从简单的页面特效到复杂的数据处理，JavaScript 可以让您的网页更加生动有趣。您将掌握 JavaScript 的基本语法、DOM 操作、事件处理等知识，为您打开创造丰富互动网页的大门。 给代码添加">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript">
<meta property="og:url" content="http://example.com/2024/07/13/JavaScript/index.html">
<meta property="og:site_name" content="晚风的喵喵屋吖">
<meta property="og:description" content="JavaScript是一种函数优先特性的轻量级、解释型或者说即时编译型的编程语言。JavaScript 是网页交互的核心，通过本课程，您将学会如何运用 JavaScript 实现动态效果和用户交互。从简单的页面特效到复杂的数据处理，JavaScript 可以让您的网页更加生动有趣。您将掌握 JavaScript 的基本语法、DOM 操作、事件处理等知识，为您打开创造丰富互动网页的大门。 给代码添加">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/index%20img.jpg">
<meta property="article:published_time" content="2024-07-13T04:40:54.263Z">
<meta property="article:modified_time" content="2024-07-15T15:52:10.465Z">
<meta property="article:author" content="晚风温柔苍生">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/index%20img.jpg"><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="http://example.com/2024/07/13/JavaScript/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.14.0-b3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.35/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>(()=>{
      const saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
      
      window.btf = {
        saveToLocal: saveToLocal,
        getScript: (url, attr = {}) => new Promise((resolve, reject) => {
          const script = document.createElement('script')
          script.src = url
          script.async = true
          script.onerror = reject
          script.onload = script.onreadystatechange = function() {
            const loadState = this.readyState
            if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
            script.onload = script.onreadystatechange = null
            resolve()
          }

          Object.keys(attr).forEach(key => {
            script.setAttribute(key, attr[key])
          })

          document.head.appendChild(script)
        }),

        getCSS: (url, id = false) => new Promise((resolve, reject) => {
          const link = document.createElement('link')
          link.rel = 'stylesheet'
          link.href = url
          if (id) link.id = id
          link.onerror = reject
          link.onload = link.onreadystatechange = function() {
            const loadState = this.readyState
            if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
            link.onload = link.onreadystatechange = null
            resolve()
          }
          document.head.appendChild(link)
        }),

        addGlobalFn: (key, fn, name = false, parent = window) => {
          const pjaxEnable = false
          if (!pjaxEnable && key.startsWith('pjax')) return

          const globalFn = parent.globalFn || {}
          const keyObj = globalFn[key] || {}
    
          if (name && keyObj[name]) return
    
          name = name || Object.keys(keyObj).length
          keyObj[name] = fn
          globalFn[key] = keyObj
          parent.globalFn = globalFn
        }
      }
    
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode
      
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })()</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JavaScript',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-07-15 23:52:10'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/favicon.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影片</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/index%20img.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="晚风的喵喵屋吖"><span class="site-name">晚风的喵喵屋吖</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影片</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">JavaScript</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-07-13T04:40:54.263Z" title="发表于 2024-07-13 12:40:54">2024-07-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-07-15T15:52:10.465Z" title="更新于 2024-07-15 23:52:10">2024-07-15</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JavaScript"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>JavaScript是一种函数优先特性的轻量级、解释型或者说即时编译型的编程语言。JavaScript 是网页交互的核心，通过本课程，您将学会如何运用 JavaScript 实现动态效果和用户交互。从简单的页面特效到复杂的数据处理，JavaScript 可以让您的网页更加生动有趣。您将掌握 JavaScript 的基本语法、DOM 操作、事件处理等知识，为您打开创造丰富互动网页的大门。</p>
<h1 id="给代码添加注释"><a href="#给代码添加注释" class="headerlink" title="给代码添加注释"></a>给代码添加注释</h1><p>JavaScript有两种写注释的方法。</p>
<ul>
<li>使用 &#x2F;&#x2F; 注释掉当前行的代码。 这是一个行内注释：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// This is an in-line comment.</span><br></pre></td></tr></table></figure></li>
<li>你也可以使用多行注释来注释你的代码，使用 &#x2F;* 开始， *&#x2F; 结束。 这是一个多行注释：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/* This is a</span><br><span class="line">multi-line comment */</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="let与const"><a href="#let与const" class="headerlink" title="let与const"></a>let与const</h1><p>let 与 var的区别与使用：</p>
<p>使用 var 关键字声明变量的最大问题之一是你可以轻松覆盖变量声明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var camper = &quot;James&quot;;</span><br><span class="line">var camper = &quot;David&quot;;</span><br><span class="line">console.log(camper);</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，camper 变量最初声明为 James，然后被覆盖为 David。 然后控制台显示字符串 David。</p>
<p>在小型应用程序中，你可能不会遇到此类问题。 但是随着你的代码库变大，你可能会意外地覆盖一个你不打算覆盖的变量。 由于此行为不会引发错误，因此搜索和修复错误变得更加困难。</p>
<p>ES6 中引入了一个名为 let 的关键字，这是对 JavaScript 的一次重大更新，以解决与 var 关键字有关的潜在问题。 你将在后面的挑战中了解其他 ES6 特性。</p>
<p>如果将上面代码中的 var 替换为 let ，则会导致错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let camper = &quot;James&quot;;</span><br><span class="line">let camper = &quot;David&quot;;</span><br></pre></td></tr></table></figure>
<p>该错误可以在你的浏览器控制台中看到。</p>
<p>所以不像 var，当你使用 let 时，同名的变量只能声明一次。</p>
<p>const的使用：</p>
<p>关键字 let 并不是声明变量的唯一新方法。 在 ES6 中，你还可以使用 const 关键字声明变量。</p>
<p>const 具有 let 的所有出色功能，另外还有一个额外的好处，即使用 const 声明的变量是只读的。 它们是一个常量值，这意味着一旦一个变量被赋值为 const，它就不能被重新赋值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const FAV_PET = &quot;Cats&quot;;</span><br><span class="line">FAV_PET = &quot;Dogs&quot;;</span><br></pre></td></tr></table></figure>
<p>由于重新分配 FAV_PET 的值，控制台将显示错误。</p>
<p>你应该始终使用 const 关键字命名不想重新分配的变量。 这有助于避免给一个常量进行额外的再次赋值。</p>
<p>注意： 通常，开发者会用大写字母作为常量标识符，用小写字母或者驼峰命名作为变量（对象或数组）标识符。 你将在后面的挑战中了解有关对象、数组以及不可变和可变值的更多信息。 同样在后面的挑战中，你将看到大写、小写或驼峰式变量标识符的示例。</p>
<p>let与const</p>
<p>更改代码，以便使用 let 或 const 声明所有变量。 当你想要改变变量时使用 let，当你想要变量保持不变时使用 const。 此外，重命名使用 const 声明的变量以符合惯例。 请勿更改分配给变量的字符串。</p>
<h1 id="理解未初始化的变量"><a href="#理解未初始化的变量" class="headerlink" title="理解未初始化的变量"></a>理解未初始化的变量</h1><p>当 JavaScript 中的变量被声明的时候，程序内部会给它一个初始值 。 当你对一个值为 的变量进行运算操作的时候，算出来的结果将会是 NaN，它的意思是 “Not a Number”。 如果你用 变量连接一个字符串，你将得到一个 的 字符串。</p>
<p>定义 3 个变量 a、b、c，并且分别给他们赋值：5、10、”I am a”，这样它们值就不会是 了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Only change code below this line</span><br><span class="line">let a=5;</span><br><span class="line">let b=10;</span><br><span class="line">let c=&quot;I am a&quot;;</span><br><span class="line">// Only change code above this line</span><br><span class="line"></span><br><span class="line">a = a + 1;</span><br><span class="line">b = b + 5;</span><br><span class="line">c = c + &quot; String!&quot;;</span><br></pre></td></tr></table></figure>

<h1 id="js七种数据类型"><a href="#js七种数据类型" class="headerlink" title="js七种数据类型"></a>js七种数据类型</h1><p>JavaScript中有七种主要的数据类型，分为两类：原始数据类型和引用数据类型。下面我会详细介绍它们以及它们的常见用法和示例：</p>
<p><em><strong>原始数据类型：</strong></em></p>
<p>字符串 (String)：字符串是存储字符（比如 “Hello, World!”）的变量。字符串可以是引号中的任意文本。您可以使用单引号或双引号：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let str = &quot;Hello, World!&quot;;</span><br><span class="line">console.log(str); // 输出: Hello, World!</span><br></pre></td></tr></table></figure>
<p>常见的字符串操作有：</p>
<p>连接：使用加号 (+) 将两个字符串连接起来。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let str1 = &quot;Hello&quot;;</span><br><span class="line">let str2 = &quot;World&quot;;</span><br><span class="line">let result = str1 + &quot;, &quot; + str2;</span><br><span class="line">console.log(result); // 输出: Hello, World</span><br></pre></td></tr></table></figure>
<p>长度：使用 length 属性获取字符串的长度。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let str = &quot;JavaScript&quot;;</span><br><span class="line">console.log(str.length); // 输出: 10</span><br></pre></td></tr></table></figure>
<p>提取字符：使用方括号加索引来提取字符串中的特定字符（索引从0开始）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let str = &quot;JavaScript&quot;;</span><br><span class="line">console.log(str[0]); // 输出: J</span><br><span class="line">console.log(str[4]); // 输出: S</span><br></pre></td></tr></table></figure>
<p>查找：使用 indexOf() 方法查找子字符串在主字符串中的位置（如果存在）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let str = &quot;JavaScript&quot;;</span><br><span class="line">console.log(str.indexOf(&quot;Script&quot;)); // 输出: 4</span><br></pre></td></tr></table></figure>
<p>替换：使用 replace() 方法替换字符串中的部分内容。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let str = &quot;JavaScript is awesome&quot;;</span><br><span class="line">let newStr = str.replace(&quot;awesome&quot;, &quot;great&quot;);</span><br><span class="line">console.log(newStr); // 输出: JavaScript is great</span><br></pre></td></tr></table></figure>
<p>数字 (Number)：JavaScript 只有一种数字类型。数字可以带小数点，也可以不带。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let x1=34.00;      //使用小数点来写</span><br><span class="line">let x2=34;             //不使用小数点来写</span><br></pre></td></tr></table></figure>
<p>布尔值 (Boolean)：用于表示逻辑上的 true 或 false。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let isTrue = true;</span><br><span class="line">if (isTrue) &#123;</span><br><span class="line">  console.log(&quot;It&#x27;s true!&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  console.log(&quot;It&#x27;s false!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>空值 (null)：表示一个空值对象，通常用于初始化变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let emptyValue = null;</span><br><span class="line">console.log(emptyValue); // 输出: null</span><br></pre></td></tr></table></figure>
<p>未定义 ()：表示一个未赋值的变量或未声明的属性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let notDefined;</span><br><span class="line">console.log(notDefined); // 输出: </span><br></pre></td></tr></table></figure>
<p><em><strong>引用数据类型：</strong></em></p>
<p>对象 (Object)：用于存储多个值的集合，每个值都有对应的键。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let person = &#123;</span><br><span class="line">  name: &quot;John&quot;,</span><br><span class="line">  age: 30,</span><br><span class="line">  isAdmin: false</span><br><span class="line">&#125;;</span><br><span class="line">console.log(person.name); // 输出: John</span><br></pre></td></tr></table></figure>
<p>数组 (Array)：用于存储多个值的有序集合，每个值都有对应的索引。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let numbers = [1, 2, 3, 4, 5];</span><br><span class="line">console.log(numbers.length); // 输出: 5</span><br></pre></td></tr></table></figure>
<p><strong>typeof 获取数据类型：</strong>我们已经学完了js的七种数据类型，在js中，定义的变量是弱类型的，那么我们该通过什么样的方式来知道变量的类型呢。typeof 是 JavaScript 中的一个运算符，用于获取操作数的数据类型。它返回一个表示操作数类型的字符串。</p>
<p>基本用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typeof operand;//operand：要检测其类型的操作数。</span><br></pre></td></tr></table></figure>
<p>返回值：</p>
<p>：如果操作数是未定义的值。<br>boolean：如果操作数是布尔值。<br>number：如果操作数是数值。<br>string：如果操作数是字符串。<br>bigint：如果操作数是大整数。<br>symbol：如果操作数是符号。<br>object：如果操作数是对象或 null。<br>function：如果操作数是函数。</p>
<p><em><strong>注意事项：</strong></em></p>
<p>typeof null 返回 “object”，这是 JavaScript 的一个历史遗留问题，因为在 JavaScript 早期版本中，null 被错误地归类为对象。这个问题由来已久，为了保持向后兼容性，没有修复这个问题。</p>
<p>对于大多数数据类型，typeof 可以很好地检测其类型。但是对于对象和数组，它只能告诉我们它们是对象，无法进一步区分具体的类型。因此，当需要详细了解对象的类型时，通常需要使用其他方法，比如 instanceof 运算符或检查对象的构造函数。</p>
<p>instanceof：instanceof 是 JavaScript 中的一个运算符，用于检测一个对象是否是某个构造函数的实例。它用于检查一个对象是否是指定类（或类的原型链上的类）的实例，返回一个布尔值。</p>
<p>基本用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object instanceof constructor</span><br></pre></td></tr></table></figure>
<p>object：要检查的对象。<br>constructor：要检查对象是否是其实例的构造函数。<br>返回值：instanceof运算符返回一个布尔值，表示对象是否是指定构造函数的实例。如果 object 是 constructor 的实例，则返回 true；否则返回 false。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;&#125;;</span><br><span class="line">console.log(obj instanceof Object); // true</span><br><span class="line"></span><br><span class="line">const arr = [];</span><br><span class="line">console.log(arr instanceof Array); // true</span><br><span class="line">console.log(arr instanceof Object); // true，数组也是对象的一种</span><br></pre></td></tr></table></figure>
<p><strong>注意事项：</strong>虽然 instanceof 可以用来检测数组，但是需要注意的是，如果在多个全局执行上下文之间使用了多个 JavaScript 引擎实例（如在 Web Worker 中），那么可能会出现 instanceof不正确的情况。因此，如果需要检测对象是否是数组，最好使用 Array.isArray() 方法，它更可靠。</p>
<p>js七种数据类型</p>
<p>定义 3 个变量 a、b、c，并且分别给他们赋值：5、10、”I am a”，这样它们值就不会是 了。</p>
<h1 id="使用模板字面量创建字符串"><a href="#使用模板字面量创建字符串" class="headerlink" title="使用模板字面量创建字符串"></a>使用模板字面量创建字符串</h1><p>模板字符串是 ES6 的另外一项新的功能。 这是一种可以轻松构建复杂字符串的方法。</p>
<p>模板字符串可以使用多行字符串和字符串插值功能。</p>
<p>请看以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const person = &#123;</span><br><span class="line">  name: &quot;Zodiac Hasbro&quot;,</span><br><span class="line">  age: 56</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const greeting = `Hello, my name is $&#123;person.name&#125;!</span><br><span class="line">I am $&#123;person.age&#125; years old.`;</span><br><span class="line"></span><br><span class="line">console.log(greeting);</span><br></pre></td></tr></table></figure>
<p>控制台将显示字符串 Hello, my name is Zodiac Hasbro! 和 I am 56 years old.。</p>
<p>这里发生了许多事情。 首先，这个例子使用反引号（&#96;），而不是引号（’ 或者 “）将字符串括起来。 其次，注意代码和输出中的字符串都是多行的。 不需要在字符串中插入 \n。 上面使用的 ${variable} 语法是一个占位符。 这样一来，你将不再需要使用 + 运算符来连接字符串。 当需要在字符串里增加变量的时候，你只需要在变量的外面括上 ${ 和 }，并将其放在模板字符串里就可以了。 同样，你可以在字符串中包含其他表达式，例如 ${a + b}。 这个新的方式使你可以更灵活地创建复杂的字符串。</p>
<p>使用模板字面量创建字符串</p>
<p>使用模板字符串的反引号的语法创建一个包含条目（li）字符串的数组。 每个条目应该是 result 对象 failure 属性的数组内的元素，并具有 class 属性，值为 text-warning。 makeList 函数应该返回列表项字符串的数组。</p>
<p>使用遍历方法（可以是任意形式的循环）输出指定值（如下）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#x27;&lt;li class=&quot;text-warning&quot;&gt;no-var&lt;/li&gt;&#x27;,</span><br><span class="line">  &#x27;&lt;li class=&quot;text-warning&quot;&gt;var-on-top&lt;/li&gt;&#x27;,</span><br><span class="line">  &#x27;&lt;li class=&quot;text-warning&quot;&gt;linebreak&lt;/li&gt;&#x27;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const result = &#123;</span><br><span class="line">  success: [&quot;max-length&quot;, &quot;no-amd&quot;, &quot;prefer-arrow-functions&quot;],</span><br><span class="line">  failure: [&quot;no-var&quot;, &quot;var-on-top&quot;, &quot;linebreak&quot;],</span><br><span class="line">  skipped: [&quot;no-extra-semi&quot;, &quot;no-dup-keys&quot;]</span><br><span class="line">&#125;;</span><br><span class="line">function makeList(arr) &#123;</span><br><span class="line">  // Only change code below this line</span><br><span class="line"> const failureItems = [];</span><br><span class="line">  for(var i=0;i&lt;arr.length;i++)&#123;</span><br><span class="line">    failureItems.push(`&lt;li class=&quot;text-warning&quot;&gt;$&#123;arr[i]&#125;&lt;/li&gt;`);</span><br><span class="line">  &#125;</span><br><span class="line">  // Only change code above this line</span><br><span class="line"></span><br><span class="line">  return failureItems;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const failuresList = makeList(result.failure);</span><br></pre></td></tr></table></figure>

<h1 id="使用-JavaScript-数组将多个值存储在一个变量中"><a href="#使用-JavaScript-数组将多个值存储在一个变量中" class="headerlink" title="使用 JavaScript 数组将多个值存储在一个变量中"></a>使用 JavaScript 数组将多个值存储在一个变量中</h1><p>使用 JavaScript 数组将多个值存储在一个变量中：</p>
<p>使用数组（array），我们可以在一个地方存储多个数据。</p>
<p>以左方括号开始定义一个数组，以右方括号结束，里面每个元素之间用逗号隔开，例如：</p>
<p>const sandwich &#x3D; [“peanut butter”, “jelly”, “bread”];</p>
<p>将一个数组嵌套在另一个数组中：<br>您也可以在其他数组中嵌套数组，如：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const teams = [[&quot;Bulls&quot;, 23], [&quot;White Sox&quot;, 45]];</span><br></pre></td></tr></table></figure>
<p>这也叫做多维数组（multi-dimensional array）。</p>
<ul>
<li>通过索引访问数组中的数据：</li>
</ul>
<p>我们可以使用索引（indexes）来访问数组中的数据。</p>
<p>数组索引与字符串一样使用方括号来表示，不同的是，它们不是指定字符，而是指定数组中的一个条目。 数组索引与字符串索引一样是从 0 开始（zero-based）的，所以数组中第一个元素的索引编号是 0。</p>
<p>示例：</p>
<p>const array &#x3D; [50, 60, 70];</p>
<p>console.log(array[0]);</p>
<p>const data &#x3D; array[1];</p>
<p>console.log(array[0]) 打印 50，<br>data 的值为 60。</p>
<ul>
<li>通过索引修改数组中的数据：</li>
</ul>
<p>与字符串不同，数组的条目是可变的并且可以自由更改，即使数组是用 const 声明的。</p>
<p>示例：</p>
<p>const ourArray &#x3D; [50, 40, 30];<br>ourArray[0] &#x3D; 15;<br>ourArray 值为 [15, 40, 30]。</p>
<p>注意： 数组名与方括号之间不应该有任何空格，比如 array [0] 。 尽管 JavaScript 能够正确处理这种情况，但是当其他程序员阅读你写的代码时，这可能让他们感到困惑。</p>
<ul>
<li>使用索引访问多维数组：</li>
</ul>
<p>我们可以把多维数组看作成是数组中的数组。 当你使用括号访问你的数组时，第一组括号指的是最外层（第一层）数组中的条目，而每一对额外的括号指的是里面下一层的条目。</p>
<p>例如：</p>
<p>const arr &#x3D;<br>[<br>[1, 2, 3],<br>[4, 5, 6],<br>[7, 8, 9],<br>[[10, 11, 12], 13, 14]<br>];</p>
<p>const subarray &#x3D; arr[3];</p>
<p>const nestedSubarray &#x3D; arr[3][0];</p>
<p>const element &#x3D; arr[3][0][1];</p>
<p>在这个例子中，subarray 的值为 [[10, 11, 12], 13, 14]，<br>nestedSubarray 的值为 [10, 11, 12]，element 的值为 11 。</p>
<p>注意：数组名与方括号之间不应该有任何空格，比如 array [0][0] 甚至是 array [0] [0] 都是不允许的。 尽管 JavaScript 能够正确处理这种情况，但是当其他程序员阅读你写的代码时，这可能让他们感到困惑。</p>
<ul>
<li>使用 push 方法操作数组：</li>
</ul>
<p>将数据加到数组末尾的一种简单方法是通过push()方法。</p>
<p>push()方法接受一个或多个参数，并按照它们出现的顺序将它们附加到数组的末尾。它返回数组的新长度。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const arr1 = [1, 2, 3];</span><br><span class="line">arr1.push(4, 5);</span><br><span class="line"></span><br><span class="line">const arr2 = [&quot;Stimpson&quot;,&quot;J&quot;, &quot;cat&quot;];</span><br><span class="line">arr2.push([&quot;happy&quot;, &quot;joy&quot;]);</span><br><span class="line"></span><br><span class="line">arr1现在的值为[1,2,3,4,5]，arr2的值[“Stimpson”,“J”,“cat”,[“happy”,“joy”]]。</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 pop 方法操作数组：</li>
</ul>
<p>改变数组中数据的另一种方法是用 .pop() 函数。</p>
<p>.pop() 函数用来弹出一个数组末尾的值。 我们可以把这个弹出的值赋给一个变量存储起来。 换句话说就是 .pop() 函数移除数组末尾的元素并返回这个元素。</p>
<p>数组中任何类型的元素（数值，字符串，甚至是数组）都可以被弹出来 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const threeArr = [1, 4, 6];</span><br><span class="line">const oneDown = threeArr.pop();</span><br><span class="line">console.log(oneDown);</span><br><span class="line">console.log(threeArr);</span><br><span class="line">第一个 console.log 将显示值 6，第二个将显示值 [1, 4]。</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 shift 方法操作数组：</li>
</ul>
<p>pop() 函数用来移出数组中最后一个元素。 如果想要移出第一个元素要怎么办呢？</p>
<p>这时候我们就需要 .shift() 了。 它的工作原理就像 .pop()，但它移除的是第一个元素，而不是最后一个。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const ourArray = [&quot;Stimpson&quot;, &quot;J&quot;, [&quot;cat&quot;]];</span><br><span class="line">const removedFromOurArray = ourArray.shift();</span><br><span class="line">removedFromOurArray 值为 Stimpson，ourArray 值为 [&quot;J&quot;, [&quot;cat&quot;]]</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 unshift 方法操作数组：</li>
</ul>
<p>不仅可以 shift（移出）数组中的第一个元素，也可以 unshift（移入）一个元素到数组的头部。</p>
<p>.unshift() 函数用起来就像 .push() 函数一样，但不是在数组的末尾添加元素，unshift() 在数组的头部添加元素。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const ourArray = [&quot;Stimpson&quot;, &quot;J&quot;, &quot;cat&quot;];</span><br><span class="line">ourArray.shift();</span><br><span class="line">ourArray.unshift(&quot;Happy&quot;);</span><br><span class="line">在 shift、ourArray 后值为 [&quot;J&quot;, &quot;cat&quot;]。 在 unshift、ourArray 后值为 [&quot;Happy&quot;, &quot;J&quot;, &quot;cat&quot;]。</span><br></pre></td></tr></table></figure>

<p>eg:</p>
<p>使用 JavaScript 数组将多个值存储在一个变量中</p>
<p>创建一个名叫 myList 的购物清单。 清单的数据格式就是多维数组。</p>
<p>每个子数组中的第一个元素应该是购买的物品名称。 第二个元素应该是物品的数量，类似于：</p>
<p>[“Chocolate Bar”, 15]<br>列表中应至少有 5 个子数组。</p>
<h1 id="用函数编写可重用代码"><a href="#用函数编写可重用代码" class="headerlink" title="用函数编写可重用代码"></a>用函数编写可重用代码</h1><p>在 JavaScript 中，我们可以把代码的重复部分抽取出来，放到一个函数 （functions）中。</p>
<p>举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function functionName() &#123;</span><br><span class="line">  console.log(&quot;Hello World&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以通过函数名加上后面的小括号来调用（invoke）这个函数，就像这样： functionName(); 每次调用函数时，它都会在控制台上打印消息 Hello World。 每次调用函数时，大括号之间的所有代码都将被执行。</p>
<p>eg:</p>
<p>用函数编写可重用代码</p>
<p>先创建一个名为 reusableFunction 的函数，这个函数打印 Hi World 到控制台上。<br>然后调用这个函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function  reusableFunction()</span><br><span class="line">&#123;</span><br><span class="line">    console.log(&quot;Hi World&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reusableFunction();</span><br></pre></td></tr></table></figure>

<h1 id="将值传递给带有参数的函数"><a href="#将值传递给带有参数的函数" class="headerlink" title="将值传递给带有参数的函数"></a>将值传递给带有参数的函数</h1><p>函数的参数 （parameters）在函数调用中充当传入函数的输入占位符（也叫形参）。 函数调用时，参数可以为一个或多个。 调用函数时输入（或传递 “passed”）的实际值被称为参数（arguments）。</p>
<p>这是带有两个参数的函数，param1 和 param2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function testFun(param1, param2) &#123;</span><br><span class="line">  console.log(param1, param2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们可以调用 testFun，就像这样： testFun(“Hello”, “World”);。 我们传入了两个字符串参数， Hello 和 World。 在函数中，param1 等于字符串 Hello 以及 param2 等于字符串 World。 请注意，testFun 函数可以多次调用，每次调用时传递的参数会决定参数的实际值。</p>
<p>eg:</p>
<p>将值传递给带有参数的函数</p>
<p>创建一个名为 functionWithArgs 的函数，它可以接收两个参数，计算参数的和，将结果输出到控制台。<br>自己指定两个数字作为参数，运行函数 functionWithArgs。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function functionWithArgs(param1, param2) &#123;</span><br><span class="line">  console.log(param1+param2);</span><br><span class="line">&#125;</span><br><span class="line">functionWithArgs(1,3);</span><br><span class="line">functionWithArgs(7,9);</span><br></pre></td></tr></table></figure>

<h1 id="JavaScript-函数的值传递与引用传递"><a href="#JavaScript-函数的值传递与引用传递" class="headerlink" title="JavaScript 函数的值传递与引用传递"></a>JavaScript 函数的值传递与引用传递</h1><p>函数参数的传递方式分为值传递（pass by value）和引用传递（pass by reference），它们在处理参数时有着不同的行为。</p>
<p>JavaScript 中的基本类型（如数字、字符串、布尔值等）是通过值传递的方式传递给函数的，而对象、数组等复杂类型则是通过引用传递的方式传递给函数的。因此，对于基本类型，函数内部对参数的修改不会影响到原始变量；而对于复杂类型，函数内部对参数的修改会影响到原始变量。</p>
<p><strong>值传递（Pass by Value）：</strong></p>
<p>在值传递中，函数参数的值被复制到了一个新的变量，函数内部对该变量的操作不会影响到原始变量的值。这意味着，对参数的任何修改都只会在函数内部生效，不会影响到函数外部的变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function increment(num) &#123;</span><br><span class="line">    num++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let x = 10;</span><br><span class="line">increment(x);</span><br><span class="line">console.log(x); // 输出 10，原始变量的值未改变</span><br></pre></td></tr></table></figure>
<p>在这个例子中，x 是一个数字，作为参数传递给 increment 函数时，num 接收了 x 的值的一个副本，所以在函数内部对 num 的修改不会影响到 x 的值。</p>
<p><strong>引用传递（Pass by Reference）：</strong></p>
<p>在引用传递中，函数参数接收的是原始值的内存地址（引用），而不是值本身的副本。这意味着，函数内部对参数的操作会直接影响到原始变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function addToEnd(arr, element) &#123;</span><br><span class="line">    arr.push(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let myArray = [1, 2, 3];</span><br><span class="line">addToEnd(myArray, 4);</span><br><span class="line">console.log(myArray); // 输出 [1, 2, 3, 4]，原始数组被修改</span><br></pre></td></tr></table></figure>
<p>在这个例子中，myArray 是一个数组，作为参数传递给 addToEnd 函数时，arr 接收了 myArray 的引用，所以在函数内部对 arr 的操作会直接修改原始数组 myArray。</p>
<p>区别总结：</p>
<p>值传递：传递的是值的副本，函数内部的操作不会影响到原始变量。<br>引用传递：传递的是值的引用，函数内部的操作会直接影响到原始变量。</p>
<p>JavaScript 函数的值传递与引用传递</p>
<p>在updateArray中修改代码，实现将myList的第三个元素，更改为tiger</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function updateArray(arr,index,element)&#123;</span><br><span class="line">// Setup</span><br><span class="line">arr[index]=element;   </span><br><span class="line"></span><br><span class="line">// Only change code below this line</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let myList = [&quot;cat&quot;,&quot;dog&quot;,&quot;t&quot;]</span><br><span class="line">updateArray(myList,2,&quot;tiger&quot;)</span><br><span class="line">console.log(myList)</span><br></pre></td></tr></table></figure>

<h1 id="使用-return-给函数返回值"><a href="#使用-return-给函数返回值" class="headerlink" title="使用 return 给函数返回值"></a>使用 return 给函数返回值</h1><p>我们可以通过函数的参数（arguments）把值传入函数， 也可以使用 return 语句把数据从一个函数中传出来。</p>
<p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function plusThree(num) &#123;</span><br><span class="line">  return num + 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const answer = plusThree(5);</span><br><span class="line">//answer 的值为 8。</span><br></pre></td></tr></table></figure>
<p>plusThree 带有一个参数（argument）num，并返回（return）一个等于 num + 3 的值。</p>
<p>使用 return 给函数返回值</p>
<p>创建一个函数 timesFive 接收一个参数，把它乘以 5 之后返回。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function timesFive(num) &#123;</span><br><span class="line">  return num*5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">timesFive(5);</span><br><span class="line">timesFive(2);</span><br><span class="line">timesFive(0);</span><br></pre></td></tr></table></figure>

<h1 id="使用箭头函数编写简洁的匿名函数"><a href="#使用箭头函数编写简洁的匿名函数" class="headerlink" title="使用箭头函数编写简洁的匿名函数"></a>使用箭头函数编写简洁的匿名函数</h1><p>在 JavaScript 里，我们会经常遇到不需要给函数命名的情况，尤其是在需要将一个函数作为参数传给另外一个函数的时候。 这时，我们会创建匿名函数。 因为这些函数不会在其他地方复用，所以我们不需要给它们命名。</p>
<p>这种情况下，我们通常会使用以下语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const myFunc = function() &#123;</span><br><span class="line">  const myVar = &quot;value&quot;;</span><br><span class="line">  return myVar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ES6 提供了其他写匿名函数的方式的语法糖。 你可以使用箭头函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const myFunc = () =&gt; &#123;</span><br><span class="line">  const myVar = &quot;value&quot;;</span><br><span class="line">  return myVar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当不需要函数体，只返回一个值的时候，箭头函数允许你省略 return 关键字和外面的大括号。 这样就可以将一个简单的函数简化成一个单行语句。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const myFunc = () =&gt; &quot;value&quot;;</span><br></pre></td></tr></table></figure>
<p>这段代码默认会返回字符串 value。</p>
<p>使用箭头函数编写简洁的匿名函数<br>使用箭头函数的语法重写赋给 magic 变量的函数，使其返回一个新的 Date() new Date()。 同时不要用 var 关键字来定义任何变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const magic = () =&gt; new Date();</span><br></pre></td></tr></table></figure>
<h1 id="编写带参数的箭头函数"><a href="#编写带参数的箭头函数" class="headerlink" title="编写带参数的箭头函数"></a>编写带参数的箭头函数</h1><p>和一般的函数一样，你也可以给箭头函数传递参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const doubler = (item) =&gt; item * 2;</span><br><span class="line">doubler(4);</span><br></pre></td></tr></table></figure>
<p>doubler(4) 将返回 8。</p>
<p>如果箭头函数只有一个参数，则可以省略参数外面的括号。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const doubler = item =&gt; item * 2;</span><br></pre></td></tr></table></figure>
<p>可以给箭头函数传递多个参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const multiplier = (item, multi) =&gt; item * multi;</span><br><span class="line">multiplier(4, 2);</span><br></pre></td></tr></table></figure>
<p>multiplier(4, 2) 将返回 8。</p>
<p>编写带参数的箭头函数</p>
<p>使用箭头函数的语法重写 myConcat 函数，将 arr2 的内容添加到 arr1。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const myConcat = (arr1, arr2) =&gt; arr1.concat(arr2);</span><br><span class="line"></span><br><span class="line">console.log(myConcat([1, 2], [3, 4, 5]));</span><br></pre></td></tr></table></figure>

<h1 id="用-ES6-编写简洁的函数声明"><a href="#用-ES6-编写简洁的函数声明" class="headerlink" title="用 ES6 编写简洁的函数声明"></a>用 ES6 编写简洁的函数声明</h1><p>在 ES5 中，当我们需要在对象中定义一个函数的时候，必须像这样使用 function 关键字：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const person = &#123;</span><br><span class="line">  name: &quot;Taylor&quot;,</span><br><span class="line">  sayHello: function() &#123;</span><br><span class="line">    return `Hello! My name is $&#123;this.name&#125;.`;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用 ES6 的语法在对象中定义函数的时候，可以删除 function 关键词和冒号。 请看以下例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const person = &#123;</span><br><span class="line">  name: &quot;Taylor&quot;,</span><br><span class="line">  sayHello() &#123;</span><br><span class="line">    return `Hello! My name is $&#123;this.name&#125;.`;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用 ES6 编写简洁的函数声明</p>
<p>使用以上这种简短的语法，重构在 bicycle 对象中的 setGear 函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Only change code below this line</span><br><span class="line">const bicycle = &#123;</span><br><span class="line">  gear: 2,</span><br><span class="line">  setGear(newGear) &#123;</span><br><span class="line">    this.gear = newGear;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">// Only change code above this line</span><br><span class="line">bicycle.setGear(3);</span><br><span class="line">console.log(bicycle.gear);</span><br></pre></td></tr></table></figure>
<h1 id="全局作用域和window"><a href="#全局作用域和window" class="headerlink" title="全局作用域和window"></a>全局作用域和window</h1><p>在 JavaScript 中，作用域涉及到变量的作用范围。 在函数外定义的变量具有 全局 作用域。 这意味着，具有全局作用域的变量可以在代码的任何地方被调用。</p>
<p>未使用 let 或 const 关键字声明的变量会在 global 范围内自动创建。 当在代码其他地方无意间定义了一个变量，刚好变量名与全局变量相同，这时会产生意想不到的后果。 你应该总是用 let 或 const 声明你的变量。</p>
<p><strong>全局作用域与 window：</strong>在 JavaScript 中，如果变量或函数在任何函数体外部定义，则它们属于全局作用域。这意味着它们可以在代码的任何地方被访问。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const globalVar = &#x27;Hello&#x27;;</span><br><span class="line"></span><br><span class="line">function sayHello() &#123;</span><br><span class="line">    console.log(globalVar); // 可以访问全局变量</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayHello(); // 输出 &quot;Hello&quot;</span><br></pre></td></tr></table></figure>
<p>window 对象：在浏览器中，全局作用域中定义的所有变量和函数都是 window 对象的属性和方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(window.globalVar); // &quot;Hello&quot;</span><br></pre></td></tr></table></figure>
<p>全局作用域和window</p>
<p>使用 let 或 const，在任何函数之外声明一个名为 myGlobal 的全局变量。 并给它一个初始值 10。</p>
<p>在函数 fun1中，赋值 5 给 oopsGlobal，不使用 var、let 或 const 关键字。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// Declare the myGlobal variable below this line</span><br><span class="line"> let myGlobal=10;</span><br><span class="line"></span><br><span class="line">function fun1() &#123;</span><br><span class="line">  // Assign 5 to oopsGlobal here</span><br><span class="line">  oopsGlobal=5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Only change code above this line</span><br><span class="line"></span><br><span class="line">function fun2() &#123;</span><br><span class="line">  let output = &quot;&quot;;</span><br><span class="line">  if (typeof myGlobal != &quot;undefined&quot;) &#123;</span><br><span class="line">    output += &quot;myGlobal: &quot; + myGlobal;</span><br><span class="line">  &#125;</span><br><span class="line">  if (typeof oopsGlobal != &quot;undefined&quot;) &#123;</span><br><span class="line">    output += &quot; oopsGlobal: &quot; + oopsGlobal;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(output);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="局部作用域和函数"><a href="#局部作用域和函数" class="headerlink" title="局部作用域和函数"></a>局部作用域和函数</h1><p>在一个函数内声明的变量，以及该函数的参数都具有局部（local）作用域。 这意味着它们只在该函数内可见。</p>
<p>这是在函数 myTest 内声明局部变量 loc 的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function myTest() &#123;</span><br><span class="line">  const loc = &quot;foo&quot;;</span><br><span class="line">  console.log(loc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myTest();</span><br><span class="line">console.log(loc);</span><br></pre></td></tr></table></figure>
<p>myTest() 函数调用将在控制台中显示字符串 foo。 console.log(loc) 行（在 myTest 函数之外）将抛出错误，因为 loc 未在函数之外定义。</p>
<p>局部作用域和函数</p>
<p>编辑器有两个 console.log 来帮助您了解正在发生的事情。 检查控制台的代码输出以查看它是如何改变的。 在 myLocalScope 中声明一个本地变量 myVar 并运行测试。</p>
<p>注意： 控制台仍将显示 ReferenceError: myVar is not defined，但这不会导致测试失败。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function myLocalScope() &#123;</span><br><span class="line">  // 只修改这一行下面的代码</span><br><span class="line">  const myVar=520;</span><br><span class="line">  console.log(&#x27;inside myLocalScope&#x27;, myVar);</span><br><span class="line">&#125;</span><br><span class="line">myLocalScope();</span><br></pre></td></tr></table></figure>
<h1 id="创建-JavaScript-对象"><a href="#创建-JavaScript-对象" class="headerlink" title="创建 JavaScript 对象"></a>创建 JavaScript 对象</h1><p>你之前可能听过 object 这个词。</p>
<p>对象和 arrays 类似，区别在于数组使用索引来访问和修改数据，而对象中的数据是通过 properties 访问的。</p>
<p>对象非常适合用来存储结构化数据，可以表示真实世界中的物体，比如一只猫。</p>
<p>这里是一个猫对象的样本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const cat = &#123;</span><br><span class="line">  &quot;name&quot;: &quot;Whiskers&quot;,</span><br><span class="line">  &quot;legs&quot;: 4,</span><br><span class="line">  &quot;tails&quot;: 1,</span><br><span class="line">  &quot;enemies&quot;: [&quot;Water&quot;, &quot;Dogs&quot;]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在此示例中，所有属性都存储为字符串，例如 name、legs 和 tails。 然而，你也可以使用数字作为属性。 你甚至可以省略单字字符串属性中的引号，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const anotherObject = &#123;</span><br><span class="line">  make: &quot;Ford&quot;,</span><br><span class="line">  5: &quot;five&quot;,</span><br><span class="line">  &quot;model&quot;: &quot;focus&quot;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然而，如果你的对象有非字符串属性的话，JavaScript 会自动将它们转为字符串。</p>
<p>创建 JavaScript 对象</p>
<p>确保对象表示一只名为 myDog 的狗，包含属性 name（字符串）、legs、tails 和 friends。</p>
<p>你可以随意设置这些对象的属性值，只要 name 是字符串，legs 和 tails 是数字，friends 是数组即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const myDog = &#123;</span><br><span class="line">  // Only change code below this line</span><br><span class="line">  &quot;name&quot;:&quot;abc&quot;,</span><br><span class="line">  &quot;legs&quot;: 4,</span><br><span class="line">  &quot;tails&quot;: 1,</span><br><span class="line">  &quot;friends&quot;: [&quot;sss&quot;, &quot;wwww&quot;]</span><br><span class="line">  // Only change code above this line</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="JavaScript-运算符"><a href="#JavaScript-运算符" class="headerlink" title="JavaScript 运算符"></a>JavaScript 运算符</h1><p>运算符 &#x3D; 用于给 JavaScript 变量赋值。</p>
<p>算术运算符 + 用于把值加起来。</p>
<p>let y&#x3D;5;<br>let z&#x3D;2;<br>let x&#x3D;y+z;<br>在以上语句执行后，x 的值是：7</p>
<p>JavaScript 算术运算符：</p>
<p>与&#x2F;或值之间的算术运算。 y&#x3D;5，下面的表格解释了这些算术运算符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">运算符	描述	例子	X 运算结果	Y 运算结果</span><br><span class="line">+	加法	x=y+2	7	5</span><br><span class="line">-	减法	x=y-2	3	5</span><br><span class="line">*	乘法	x=y*2	10	5</span><br><span class="line">/	除法	x=y/2	2.5	5</span><br><span class="line">%	取模（余数）	x=y%2	1	5</span><br><span class="line">++	自增	x=++y	6	6</span><br><span class="line">x=y++	5	6</span><br><span class="line">--	自减	x=--y	4	4</span><br><span class="line">x=y--	5	4</span><br></pre></td></tr></table></figure>
<p>JavaScript 赋值运算符：</p>
<p>赋值运算符用于给 JavaScript 变量赋值。</p>
<p>给定 x&#x3D;10 和 y&#x3D;5，下面的表格解释了赋值运算符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">运算符	例子	等同于	运算结果</span><br><span class="line">=	x=y		x=5</span><br><span class="line">+=	x+=y	x=x+y	x=15</span><br><span class="line">-=	x-=y	x=x-y	x=5</span><br><span class="line">*=	x*=y	x=x*y	x=50</span><br><span class="line">/=	x/=y	x=x/y	x=2</span><br><span class="line">%=	x%=y	x=x%y	x=0</span><br></pre></td></tr></table></figure>
<p>用于字符串的 + 运算符：</p>
<p>+运算符用于把文本值或字符串变量加起来（连接起来）。</p>
<p>如需把两个或多个字符串变量连接起来，请使用 + 运算符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">txt1=&quot;What a very&quot;;</span><br><span class="line">txt2=&quot;nice day&quot;;</span><br><span class="line">txt3=txt1+txt2;</span><br><span class="line">txt3 运算结果：What a verynice day</span><br></pre></td></tr></table></figure>
<p>对字符串和数字进行加法运算：</p>
<p>两个数字相加，返回数字相加的和，如果数字与字符串相加，返回字符串，如下实例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x=5+5;</span><br><span class="line">y=&quot;5&quot;+5;</span><br><span class="line">z=&quot;Hello&quot;+5;</span><br><span class="line">x,y, 和 z 输出结果为：</span><br><span class="line"></span><br><span class="line">10</span><br><span class="line">55</span><br><span class="line">Hello5</span><br></pre></td></tr></table></figure>
<p>JavaScript 运算符</p>
<p>在这个挑战中，我们为你提供名词、动词、形容词和副词。 你需要使用合适单词以及我们提供的单词来形成完整的句子。</p>
<p>你需要使用字符串连接运算符 + 来拼接字符串变量：myNoun、myAdjective、myVerb 和 myAdverb，以构建一个新字符串。 然后，将新字符串赋给 wordBlanks 变量。 你不应该更改分配给变量的单词。</p>
<p>你还需要考虑字符串中的空格，确保句子的所有单词之间有空格。 结果应该是一个完整的句子。</p>
<h1 id="JavaScript-比较-和-逻辑运算符"><a href="#JavaScript-比较-和-逻辑运算符" class="headerlink" title="JavaScript 比较 和 逻辑运算符"></a>JavaScript 比较 和 逻辑运算符</h1><p>比较和逻辑运算符用于测试 true 或者 false。</p>
<p><em><strong>比较运算符：</strong></em></p>
<p>比较运算符在逻辑语句中使用，以测定变量或值是否相等。</p>
<p>x&#x3D;5，下面的表格解释了比较运算符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">运算符	描述	比较	返回值</span><br><span class="line">==	等于	x==8	false</span><br><span class="line">x==5	true</span><br><span class="line">===	绝对等于（值和类型均相等）	x===&quot;5&quot;	false</span><br><span class="line">x===5	true</span><br><span class="line">!=	不等于	x!=8	true</span><br><span class="line">!==	不绝对等于（值和类型有一个不相等，或两个都不相等）	x!==&quot;5&quot;	true</span><br><span class="line">x!==5	false</span><br><span class="line">&gt;	大于	x&gt;8	false</span><br><span class="line">&lt;	小于	x&lt;8	true</span><br><span class="line">&gt;=	大于或等于	x&gt;=8	false</span><br><span class="line">&lt;=	小于或等于	x&lt;=8	true</span><br></pre></td></tr></table></figure>
<p>如何使用：</p>
<p>可以在条件语句中使用比较运算符对值进行比较，然后根据结果来采取行动：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (age&lt;18) x=&quot;Too young&quot;;</span><br></pre></td></tr></table></figure>
<p>您将在本教程的下一节中学习更多有关条件语句的知识。</p>
<p><em><strong>逻辑运算符：</strong></em></p>
<p>逻辑运算符用于测定变量或值之间的逻辑。</p>
<p>给定 x&#x3D;6 以及 y&#x3D;3，下表解释了逻辑运算符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">运算符	描述	例子</span><br><span class="line">&amp;&amp;	and(两边都为true，结果为true；否则为false)	(x &lt; 10 &amp;&amp; y &gt; 1) 为 true</span><br><span class="line">||	or(其中任何一边为true，结果就为true；两边都)	(x==5 || y==5) 为 false</span><br><span class="line">!	not(取反操作，true的反为false，false的反为true)	!(x==y) 为 true</span><br></pre></td></tr></table></figure>
<p><em><strong>条件运算符：</strong></em></p>
<p>条件运算符也称为三元运算符。</p>
<p>语法是：a ? b : c, a 是条件，当条件返回 true 的时候运行代码 b，当条件返回 false 的时候运行代码 c。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let c = a &gt; b ? &quot;a is greater&quot; : &quot;b is greater or equal&quot;;</span><br></pre></td></tr></table></figure>
<p>若a大于b，c的值就为a is greater</p>
<p>否则，c的值就为b is greater or equal</p>
<p><strong>空值合并运算符（??）：</strong>是一个逻辑运算符，当左侧的操作数为 null 或者 时，返回其右侧操作数，否则返回左侧操作数。</p>
<p>与逻辑或运算符 || 不同的是，逻辑或运算符中左侧存在’’或0时，会认作假值，则会返回右边的操作数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const foo = null ?? &#x27;default string&#x27;;</span><br><span class="line">console.log(foo);</span><br><span class="line">// 输出: &quot;default string&quot;</span><br><span class="line"></span><br><span class="line">const baz = 0 ?? 42;</span><br><span class="line">console.log(baz);</span><br><span class="line">// 输出: 0</span><br><span class="line"></span><br><span class="line">//当使用逻辑或运算符时，0会当作假值，就会返回右侧值</span><br><span class="line">const sec = 0 || 42;</span><br><span class="line">console.log(sec);</span><br><span class="line">// 输出: 42</span><br></pre></td></tr></table></figure>
<p>所以 ?? 被称作空值合并运算符，他会防止把一些不为空值的识别为假，防止发生意料之外的行为，而不把’’和0当作空值。</p>
<p>JavaScript 比较 和 逻辑运算符<br>在 checkEqual 函数中使用三元运算符检查两个数字是否相等。 函数应该返回 Equal 或字符串 Not Equal。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function checkEqual(a, b) &#123;</span><br><span class="line">return(a == b ? &quot;Equal&quot; : &quot;Not Equal&quot;);//开始不通过，因为不用=，要用==</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">checkEqual(1, 2);</span><br><span class="line">checkEqual(1, 1);</span><br><span class="line">checkEqual(1, -1);</span><br></pre></td></tr></table></figure>

<h1 id="JavaScript-if…Else-语句"><a href="#JavaScript-if…Else-语句" class="headerlink" title="JavaScript if…Else 语句"></a>JavaScript if…Else 语句</h1><p>条件语句 if…else 用于基于不同的条件来执行不同的动作。</p>
<p>通常在写代码时，您总是需要为不同的决定来执行不同的动作。您可以在代码中使用条件语句来完成该任务。</p>
<p>在 JavaScript 中，我们可使用以下条件语句：</p>
<p>if 语句 - 只有当指定条件为 true 时，使用该语句来执行代码</p>
<p>if…else 语句 - 当条件为 true 时执行代码，当条件为 false 时执行其他代码</p>
<p>if…else if….else 语句- 使用该语句来选择多个代码块之一来执行</p>
<p>switch 语句 - 使用该语句来选择多个代码块之一来执行</p>
<p><strong>if 语句：</strong>只有当指定条件为 true 时，该语句才会执行代码。</p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (condition)</span><br><span class="line">&#123;</span><br><span class="line">    当条件为 true 时执行的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请使用小写的 if。使用大写字母（IF）会生成 JavaScript 错误！</p>
<p>示例：当时间小于 20:00 时，生成问候 “Good day”：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (time&lt;20)</span><br><span class="line">&#123;</span><br><span class="line">    x=&quot;Good day&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，在这个语法中，没有 ..else..。您已经告诉浏览器只有在指定条件为 true 时才执行代码。</p>
<p><strong>if…else 语句：</strong>请使用 if….else 语句在条件为 true 时执行代码，在条件为 false 时执行其他代码。</p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (condition)</span><br><span class="line">&#123;</span><br><span class="line">    当条件为 true 时执行的代码</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">    当条件不为 true 时执行的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例：当时间小于 20:00 时，生成问候 “Good day”，否则生成问候 “Good evening”。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (time&lt;20)</span><br><span class="line">&#123;</span><br><span class="line">    x=&quot;Good day&quot;;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">    x=&quot;Good evening&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>if…else if…else 语句：</strong>使用 if….else if…else 语句来选择多个代码块之一来执行。</p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if (condition1)</span><br><span class="line">&#123;</span><br><span class="line">    当条件 1 为 true 时执行的代码</span><br><span class="line">&#125;</span><br><span class="line">else if (condition2)</span><br><span class="line">&#123;</span><br><span class="line">    当条件 2 为 true 时执行的代码</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">  当条件 1 和 条件 2 都不为 true 时执行的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例：如果时间小于 10:00，则生成问候 “Good morning”，如果时间大于 10:00 小于 20:00，则生成问候 “Good day”，否则生成问候 “Good evening”：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if (time&lt;10)</span><br><span class="line">&#123;</span><br><span class="line">    document.write(&quot;&lt;b&gt;早上好&lt;/b&gt;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else if (time&gt;=10 &amp;&amp; time&lt;20)</span><br><span class="line">&#123;</span><br><span class="line">    document.write(&quot;&lt;b&gt;今天好&lt;/b&gt;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">    document.write(&quot;&lt;b&gt;晚上好!&lt;/b&gt;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JavaScript if…Else 语句<br>请将 if&#x2F;else if 语句串联起来，实现下面的逻辑：</p>
<p>num &lt; 5 - 返回 Tiny<br>num &lt; 10 - 返回 Small<br>num &lt; 15 - 返回 Medium<br>num &lt; 20 - 返回 Large<br>num &gt;&#x3D; 20 - 返回 Huge</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">function testSize(num) &#123;</span><br><span class="line">  // Only change code below this line</span><br><span class="line">if(num&lt;5)</span><br><span class="line">&#123;</span><br><span class="line">  return &quot;Tiny&quot;;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">  if(num&lt;10)</span><br><span class="line">  &#123;</span><br><span class="line">    return &quot;Small&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  else&#123;</span><br><span class="line">    if(num&lt;15)</span><br><span class="line">    &#123;</span><br><span class="line">      return &quot;Medium&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">      if(num&lt;20)</span><br><span class="line">      &#123;</span><br><span class="line">        return &quot;Large&quot;;</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">        return &quot;Huge&quot;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  return &quot;Change Me&quot;;</span><br><span class="line">  // Only change code above this line</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">testSize(7);</span><br></pre></td></tr></table></figure>

<h1 id="JavaScript-switch-语句"><a href="#JavaScript-switch-语句" class="headerlink" title="JavaScript switch 语句"></a>JavaScript switch 语句</h1><p>switch 语句用于基于不同的条件来执行不同的动作。</p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">switch(n)</span><br><span class="line">&#123;</span><br><span class="line">    case 1:</span><br><span class="line">        执行代码块 1</span><br><span class="line">        break;</span><br><span class="line">    case 2:</span><br><span class="line">        执行代码块 2</span><br><span class="line">        break;</span><br><span class="line">    default:</span><br><span class="line">        与 case 1 和 case 2 不同时执行的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>工作原理：首先设置表达式 n（通常是一个变量）。随后表达式的值会与结构中的每个 case 的值做比较。如果存在匹配，则与该 case 关联的代码块会被执行。请使用 break 来阻止代码自动地向下一个 case 运行。</p>
<p>示例：显示今天星期几。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let day = 2;</span><br><span class="line">switch (day) </span><br><span class="line">&#123; </span><br><span class="line">  case 0:x=&quot;今天是星期日&quot;; </span><br><span class="line">  break; </span><br><span class="line">  case 1:x=&quot;今天是星期一&quot;; </span><br><span class="line">  break; </span><br><span class="line">  case 2:x=&quot;今天是星期二&quot;; </span><br><span class="line">  break; </span><br><span class="line">  case 3:x=&quot;今天是星期三&quot;; </span><br><span class="line">  break; </span><br><span class="line">  case 4:x=&quot;今天是星期四&quot;; </span><br><span class="line">  break; </span><br><span class="line">  case 5:x=&quot;今天是星期五&quot;; </span><br><span class="line">  break; </span><br><span class="line">  case 6:x=&quot;今天是星期六&quot;; </span><br><span class="line">  break; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>x 的运行结果：今天是星期二</p>
<p><strong>default 关键词：</strong>使用 default 关键词来规定匹配不存在时做的事情：</p>
<p>示例：如果不存在匹配的内容，则会输出默认的消息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var day = 3;</span><br><span class="line">switch (day)</span><br><span class="line">&#123;</span><br><span class="line">    case 0:x=&quot;今天是星期天&quot;;</span><br><span class="line">    break;</span><br><span class="line">    case 6:x=&quot;今天是星期六&quot;;</span><br><span class="line">    break;</span><br><span class="line">    default:</span><br><span class="line">    x=&quot;期待周末&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>x 的运行结果：期待周末</p>
<p>在 Switch 语句添加多个相同选项：</p>
<p>如果你忘了给 switch 的每一条 case 添加 break，那么后续的 case 会一直执行，直到遇见 break 为止。 如果你想为 switch 中的多个不同的输入设置相同的结果，可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let result = &quot;&quot;;</span><br><span class="line">switch (val) &#123;</span><br><span class="line">  case 1:</span><br><span class="line">  case 2:</span><br><span class="line">  case 3:</span><br><span class="line">    result = &quot;1, 2, or 3&quot;;</span><br><span class="line">    break;</span><br><span class="line">  case 4:</span><br><span class="line">    result = &quot;4 alone&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，1、2、3 都会有相同的结果。</p>
<p>JavaScript switch 语句</p>
<p>请写一个 switch 语句，按如下条件设置 answer ：</p>
<p>1-3 - Low<br>4-6 - Mid<br>7-9 - High</p>
<p>提示： 你的 case 应写全范围中的每一个数字。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">function sequentialSizes(val) &#123;</span><br><span class="line">  let answer = &quot;&quot;;</span><br><span class="line">  // Only change code below this line</span><br><span class="line">  switch (val) &#123;</span><br><span class="line">  case 1:</span><br><span class="line">   answer = &quot;Low&quot;;</span><br><span class="line">   break;</span><br><span class="line">  case 2:</span><br><span class="line">   answer = &quot;Low&quot;;</span><br><span class="line">   break;</span><br><span class="line">  case 3:</span><br><span class="line">   answer = &quot;Low&quot;;</span><br><span class="line">   break;</span><br><span class="line">    </span><br><span class="line">  case 4:</span><br><span class="line">    answer = &quot;Mid&quot;;</span><br><span class="line">    break;</span><br><span class="line">  case 5:</span><br><span class="line">    answer = &quot;Mid&quot;;</span><br><span class="line">    break;</span><br><span class="line">  case 6:</span><br><span class="line">    answer = &quot;Mid&quot;;</span><br><span class="line">    break;   </span><br><span class="line"></span><br><span class="line">  case 7:</span><br><span class="line">    answer = &quot;High&quot;;</span><br><span class="line">    break;</span><br><span class="line">  case 8:</span><br><span class="line">    answer = &quot;High&quot;;</span><br><span class="line">    break;</span><br><span class="line">  case 9:</span><br><span class="line">   answer = &quot;High&quot;;</span><br><span class="line">    break;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // Only change code above this line</span><br><span class="line">  return answer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sequentialSizes(1);</span><br></pre></td></tr></table></figure>

<h1 id="JavaScript-for-循环"><a href="#JavaScript-for-循环" class="headerlink" title="JavaScript for 循环"></a>JavaScript for 循环</h1><p>循环可以将代码块执行指定的次数。</p>
<p><strong>JavaScript 循环：</strong>如果您希望一遍又一遍地运行相同的代码，并且每次的值都不同，那么使用循环是很方便的。</p>
<p>我们可以这样输出数组的值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//一般写法</span><br><span class="line">console.log(cars[0]); </span><br><span class="line">console.log(cars[1]); </span><br><span class="line">console.log(cars[2]); </span><br><span class="line">console.log(cars[3]); </span><br><span class="line">console.log(cars[4]); </span><br><span class="line">console.log(cars[5]);</span><br><span class="line">//使用for循环</span><br><span class="line">for (let i=0;i&lt;cars.length;i++)</span><br><span class="line">&#123; </span><br><span class="line">    console.log(cars[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不同类型的循环：</p>
<p>JavaScript 支持不同类型的循环：</p>
<p>for - 循环代码块一定的次数</p>
<p>for&#x2F;in - 循环遍历对象的属性</p>
<p>while - 当指定的条件为 true 时循环指定的代码块</p>
<p>do&#x2F;while - 同样当指定的条件为 true 时循环指定的代码块1</p>
<p><strong>For 循环：</strong>for 循环是您在希望创建循环时常会用到的工具。</p>
<p>下面是 for 循环的语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for (语句 1; 语句 2; 语句 3)</span><br><span class="line">&#123;</span><br><span class="line">    被执行的代码块</span><br><span class="line">&#125;</span><br><span class="line">语句 1 （代码块）开始前执行</span><br><span class="line"></span><br><span class="line">语句 2 定义运行循环（代码块）的条件</span><br><span class="line"></span><br><span class="line">语句 3 在循环（代码块）已被执行之后执行</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (let i=0; i&lt;5; i++)</span><br><span class="line">&#123;</span><br><span class="line">      x=x + &quot;该数字为 &quot; + i + &quot;&lt;br&gt;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>语句 1：</p>
<p>通常我们会使用语句 1 初始化循环中所用的变量 (let i&#x3D;0)。</p>
<p>语句 1 是可选的，也就是说不使用语句 1 也可以。</p>
<p>您可以在语句 1 中初始化任意（或者多个）值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (let i=0,len=cars.length; i&lt;len; i++)</span><br><span class="line">&#123; </span><br><span class="line">    console.log(cars[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时您还可以省略语句 1（比如在循环开始前已经设置了值时）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let i=2,len=cars.length;</span><br><span class="line">for (; i&lt;len; i++)</span><br><span class="line">&#123; </span><br><span class="line">    console.log(cars[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>语句 2：</p>
<p>通常语句 2 用于评估初始变量的条件。</p>
<p>语句 2 同样是可选的。</p>
<p>如果语句 2 返回 true，则循环再次开始，如果返回 false，则循环将结束。</p>
<p>注意：如果您省略了语句 2，那么必须在循环内提供 break。否则循环就无法停下来。这样有可能令浏览器崩溃。请在本教程稍后的章节阅读有关 break 的内容。</p>
<p>语句 3：</p>
<p>通常语句 3 会增加初始变量的值。</p>
<p>语句 3 也是可选的。</p>
<p>语句 3 有多种用法。增量可以是负数 (i–)，或者更大 (i&#x3D;i+15)。</p>
<p>语句 3 也可以省略（比如当循环内部有相应的代码时）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var i=0,len=cars.length;</span><br><span class="line">for (; i&lt;len; )</span><br><span class="line">&#123; </span><br><span class="line">    document.write(cars[i] + &quot;&lt;br&gt;&quot;);</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JavaScript for 循环</p>
<p>声明并初始化一个变量 total 值为 0。 使用 for 循环，使得 total 的值为 myArr 的数组中的每个元素的值的总和。 注：使用myArr.length可以获取到数组的长度</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Setup</span><br><span class="line">const myArr = [2, 3, 4, 5, 6];</span><br><span class="line"></span><br><span class="line">// Only change code below this line</span><br><span class="line"></span><br><span class="line">let total = 0;</span><br><span class="line">for (let i = 0,len = myArr.length; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line">    total = total+myArr[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="JavaScript-while-循环"><a href="#JavaScript-while-循环" class="headerlink" title="JavaScript while 循环"></a>JavaScript while 循环</h1><p>只要指定条件为 true，循环就可以一直执行代码块。</p>
<p><strong>while 循环：</strong>while 循环会在指定条件为真时循环执行代码块。</p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while (条件)</span><br><span class="line">&#123;</span><br><span class="line">    需要执行的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例：本例中的循环将继续运行，只要变量 i 小于 5：i 等于 5 时，结束循环</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while (i&lt;5)</span><br><span class="line">&#123;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>do&#x2F;while 循环：</strong>do&#x2F;while 循环是 while 循环的变体。该循环会在检查条件是否为真之前执行一次代码块，然后如果条件为真的话，就会重复这个循环。</p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//do/while循环，实现执行一段代码，再进行判断</span><br><span class="line">do</span><br><span class="line">&#123;</span><br><span class="line">    需要执行的代码</span><br><span class="line">&#125;</span><br><span class="line">while (条件);</span><br></pre></td></tr></table></figure>
<p>示例：下面的例子使用 do&#x2F;while 循环。该循环至少会执行一次，即使条件为 false 它也会执行一次，因为代码块会在条件被测试前执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">do</span><br><span class="line">&#123;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line">while (i&lt;5);</span><br></pre></td></tr></table></figure>
<p>JavaScript while 循环</p>
<p>通过一个 while 循环，把从 5 到 0（包括 5 和 0） 的值添加到 myArray 中。 注：往myArray中添加值，可以使用push</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Setup</span><br><span class="line">const myArray = [];</span><br><span class="line"></span><br><span class="line">// Only change code below this line</span><br><span class="line">let i=5;</span><br><span class="line">while(i&gt;=0)</span><br><span class="line">&#123;</span><br><span class="line">  myArray.push(i);</span><br><span class="line">  i--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="JavaScript-break-和-continue-语句"><a href="#JavaScript-break-和-continue-语句" class="headerlink" title="JavaScript break 和 continue 语句"></a>JavaScript break 和 continue 语句</h1><p>break 语句用于跳出循环。</p>
<p>continue 用于跳过循环中的一个迭代。</p>
<p>break 语句：</p>
<p>我们已经在本教程之前的章节中见到过 break 语句。它用于跳出 switch() 语句。</p>
<p>break 语句可用于跳出循环。</p>
<p>break 语句跳出循环后，会继续执行该循环之后的代码（如果有的话）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for (i=0;i&lt;10;i++)</span><br><span class="line">&#123;</span><br><span class="line">    if (i==3)</span><br><span class="line">    &#123;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    x=x + &quot;The number is &quot; + i + &quot;&lt;br&gt;&quot;;</span><br><span class="line">&#125;</span><br><span class="line">//该循环执行到第3次就结束循环，所以该循环只执行了三次</span><br></pre></td></tr></table></figure>
<p><strong>continue 语句：</strong>continue 语句中断当前的循环中的一次迭代，然后继续循环下一个迭代。 以下例子在值为 3 时，直接跳过：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (i=0;i&lt;=10;i++)</span><br><span class="line">&#123;</span><br><span class="line">    if (i==3) continue;</span><br><span class="line">    x=x + &quot;The number is &quot; + i + &quot;&lt;br&gt;&quot;;</span><br><span class="line">&#125;</span><br><span class="line">//该循环执行到i 等于 3 时，就会跳过这次循环，所以循环总共执行了10次</span><br></pre></td></tr></table></figure>
<p>JavaScript break 和 continue 语句</p>
<p>使用任意循环语句，把 0 到 5 中除去 3 后的值添加到 myArray 中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Setup</span><br><span class="line">const myArray = [];</span><br><span class="line"></span><br><span class="line">// Only change code below this line</span><br><span class="line">for (let i=0;i&lt;=5;i++)</span><br><span class="line">&#123;</span><br><span class="line">    if (i==3) continue;</span><br><span class="line">    myArray.push(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="复合赋值之"><a href="#复合赋值之" class="headerlink" title="复合赋值之 &#x2F;&#x3D;"></a>复合赋值之 &#x2F;&#x3D;</h1><p>&#x2F;&#x3D; 操作符是让变量与另一个数相除并赋值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myVar = myVar / 5;</span><br></pre></td></tr></table></figure>
<p>将 myVar 除以 5。 等价于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myVar /= 5;</span><br></pre></td></tr></table></figure>
<p>复合赋值之 &#x2F;&#x3D;</p>
<p>使用 &#x2F;&#x3D; 操作符对 a，b 和 c 实现相除赋值操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let a = 48;</span><br><span class="line">let b = 108;</span><br><span class="line">let c = 33;</span><br><span class="line"></span><br><span class="line">// 只修改这一行下面的代码</span><br><span class="line">a /= 12;</span><br><span class="line">b /= 4;</span><br><span class="line">c /= 11;</span><br></pre></td></tr></table></figure>

<h1 id="通过点号表示法访问对象属性-1"><a href="#通过点号表示法访问对象属性-1" class="headerlink" title="通过点号表示法访问对象属性(1)"></a>通过点号表示法访问对象属性(1)</h1><p>和访问数组类似，访问对象属性有两种方式：点号表示法（.）和方括号表示法（[]）。</p>
<p>如果我们已经提前知道要访问的属性名，使用点号表示法是最方便的。</p>
<p>这里是一个用点符号（.）读取对象属性的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const myObj = &#123;</span><br><span class="line">  prop1: &quot;val1&quot;,</span><br><span class="line">  prop2: &quot;val2&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const prop1val = myObj.prop1;</span><br><span class="line">const prop2val = myObj.prop2;</span><br></pre></td></tr></table></figure>
<p>prop1val 的值将为字符串 val1，并且prop2val 的值将为字符串 val2。</p>
<p><strong>可选链运算符（?.）：</strong>可选链运算符（?.）允许读取位于连接对象链深处的属性的值，而不必明确验证链中的每个引用是否有效。?. 运算符的功能类似于 . 链式运算符，不同之处在于，在引用为空 (nullish ) (null 或者 ) 的情况下不会引起错误，该表达式短路返回值是 。与函数调用一起使用时，如果给定的函数不存在，则返回 。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const adventurer = &#123;</span><br><span class="line">  name: &#x27;Alice&#x27;,</span><br><span class="line">  cat: &#123;</span><br><span class="line">    name: &#x27;Dinah&#x27;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const dogName = adventurer.dog?.name;</span><br><span class="line">console.log(dogName);</span><br><span class="line">// 输出: </span><br><span class="line"></span><br><span class="line">//函数调用时如果被调用的方法不存在，使用可选链可以使表达式自动返回而不是抛出一个异常。</span><br><span class="line">console.log(adventurer.someNonExistentMethod?.());</span><br><span class="line">// 输出: </span><br></pre></td></tr></table></figure>
<p>通过点号表示法访问对象属性(1)</p>
<p>使用点号读取 testObj 的属性值。 将变量 hatValue 的值设置为该对象的 hat 属性的值，并将变量 shirtValue 的值设置为该对象的 shirt 属性的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Setup</span><br><span class="line">const testObj = &#123;</span><br><span class="line">  &quot;hat&quot;: &quot;ballcap&quot;,</span><br><span class="line">  &quot;shirt&quot;: &quot;jersey&quot;,</span><br><span class="line">  &quot;shoes&quot;: &quot;cleats&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// Only change code below this line</span><br><span class="line">const hatValue = testObj.hat;      // Change this line</span><br><span class="line">const shirtValue = testObj.shirt;    // Change this line</span><br><span class="line">const undefineValue = testObj.first?.second    // Change this line</span><br></pre></td></tr></table></figure>

<h1 id="使用方括号表示法访问对象属性"><a href="#使用方括号表示法访问对象属性" class="headerlink" title="使用方括号表示法访问对象属性"></a>使用方括号表示法访问对象属性</h1><p>访问对象属性的第二种方式是方括号表示法（[]）。 如果你想访问的属性名中包含空格，就必须使用方括号表示法来获取它的属性值。</p>
<p>当然，如果属性名不包含空格，也可以使用方括号表示法。</p>
<p>这是一个使用方括号表示法读取对象属性的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const myObj = &#123;</span><br><span class="line">  &quot;Space Name&quot;: &quot;Kirk&quot;,</span><br><span class="line">  &quot;More Space&quot;: &quot;Spock&quot;,</span><br><span class="line">  &quot;NoSpace&quot;: &quot;USS Enterprise&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">myObj[&quot;Space Name&quot;];</span><br><span class="line">myObj[&#x27;More Space&#x27;];</span><br><span class="line">myObj[&quot;NoSpace&quot;];</span><br></pre></td></tr></table></figure>
<p>myObj[“Space Name”] 将会是字符串 Kirk，myObj[‘More Space’] 将会是字符串 Spock，并且myObj[“NoSpace”] 将会是字符串 USS Enterprise。</p>
<p>注意，如果属性名中包含空格，就必须使用引号（单引号或双引号）将它们包裹起来。</p>
<p>使用方括号表示法访问对象属性</p>
<p>使用方括号读取 testObj 中 an entree 和 the drink 的属性值，并分别将它们赋值给 entreeValue 和 drinkValue。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Setup</span><br><span class="line">const testObj = &#123;</span><br><span class="line">  &quot;an entree&quot;: &quot;hamburger&quot;,</span><br><span class="line">  &quot;my side&quot;: &quot;veggies&quot;,</span><br><span class="line">  &quot;the drink&quot;: &quot;water&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// Only change code below this line</span><br><span class="line">const entreeValue = testObj[&quot;an entree&quot;];   // Change this line</span><br><span class="line">const drinkValue = testObj[&quot;the drink&quot;];    // Change this line</span><br></pre></td></tr></table></figure>

<h1 id="通过变量访问对象属性"><a href="#通过变量访问对象属性" class="headerlink" title="通过变量访问对象属性"></a>通过变量访问对象属性</h1><p>对对象上使用方括号表示法，还可以访问对象上作为变量值存储的属性。 当你需要遍历对象的所有属性，或者根据一个变量的值查找对应的属性值时，这种写法尤其适用。</p>
<p>以下是一个使用变量来访问属性的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const dogs = &#123;</span><br><span class="line">  Fido: &quot;Mutt&quot;,</span><br><span class="line">  Hunter: &quot;Doberman&quot;,</span><br><span class="line">  Snoopie: &quot;Beagle&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const myDog = &quot;Hunter&quot;;</span><br><span class="line">const myBreed = dogs[myDog];</span><br><span class="line">console.log(myBreed);</span><br></pre></td></tr></table></figure>
<p>字符串 Doberman 将会出现在控制台中。</p>
<p>请注意，我们在使用变量名访问属性时，不要使用引号引起来，因为我们使用的是 值，而不是 属性名。</p>
<p>通过变量访问对象属性</p>
<p>将 playerNumber 变量设置为 16。 然后，使用该变量查找播放器的名称并将其分配给 player。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Setup</span><br><span class="line">const testObj = &#123;</span><br><span class="line">  12: &quot;Namath&quot;,</span><br><span class="line">  16: &quot;Montana&quot;,</span><br><span class="line">  19: &quot;Unitas&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// Only change code below this line</span><br><span class="line">const playerNumber = 16;  // Change this line</span><br><span class="line">const player = testObj[playerNumber];   // Change this line</span><br></pre></td></tr></table></figure>
<h1 id="更新对象属性"><a href="#更新对象属性" class="headerlink" title="更新对象属性"></a>更新对象属性</h1><p>在你创建了 JavaScript 对象后，你可以随时更新它的属性，就像更新任何其他变量那样。 你可以使用点或中括号操作符来更新。</p>
<p>举个例子，让我们看看 ourDog：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const ourDog = &#123;</span><br><span class="line">  &quot;name&quot;: &quot;Camper&quot;,</span><br><span class="line">  &quot;legs&quot;: 4,</span><br><span class="line">  &quot;tails&quot;: 1,</span><br><span class="line">  &quot;friends&quot;: [&quot;everything!&quot;]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>既然他是一个特别愉快的狗，让我们将他的名字更改为字符串 Happy Camper。 这有两种方式来更新对象的 name 属性： ourDog.name &#x3D; “Happy Camper”; 或 ourDog[“name”] &#x3D; “Happy Camper”;。更新后，ourDog.name 的值就不再是 Camper，而是 Happy Camper。</p>
<p>更新对象属性</p>
<p>更新 myDog 对象的 name 属性。 让它的名字从 Coder 变成 Happy Coder。 你可以使用点号表示法或方括号表示法来完成此挑战。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Setup</span><br><span class="line">const myDog = &#123;</span><br><span class="line">  &quot;name&quot;: &quot;Coder&quot;,</span><br><span class="line">  &quot;legs&quot;: 4,</span><br><span class="line">  &quot;tails&quot;: 1,</span><br><span class="line">  &quot;friends&quot;: [&quot;freeCodeCamp Campers&quot;]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// Only change code below this line</span><br><span class="line">myDog.name = &quot;Happy Coder&quot;;</span><br></pre></td></tr></table></figure>
<h1 id="给-JavaScript-对象添加新属性"><a href="#给-JavaScript-对象添加新属性" class="headerlink" title="给 JavaScript 对象添加新属性"></a>给 JavaScript 对象添加新属性</h1><p>你也可以像更改属性一样给 JavaScript 对象添加属性。</p>
<p>这里展示了如何给 ourDog 添加一个属性 bark：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ourDog.bark = &quot;bow-wow&quot;;</span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">ourDog[&quot;bark&quot;] = &quot;bow-wow&quot;;</span><br></pre></td></tr></table></figure>
<p>现在，当我们执行 ourDog.bark 时，就能得到他的叫声，bow-wow。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const ourDog = &#123;</span><br><span class="line">  &quot;name&quot;: &quot;Camper&quot;,</span><br><span class="line">  &quot;legs&quot;: 4,</span><br><span class="line">  &quot;tails&quot;: 1,</span><br><span class="line">  &quot;friends&quot;: [&quot;everything!&quot;]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ourDog.bark = &quot;bow-wow&quot;;</span><br></pre></td></tr></table></figure>
<p>给 JavaScript 对象添加新属性</p>
<p>给 myDog 添加一个属性 bark ，并将其设置为狗的声音，比如 “woof“。 可以使用点操作符或者中括号操作符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const myDog = &#123;</span><br><span class="line">  &quot;name&quot;: &quot;Happy Coder&quot;,</span><br><span class="line">  &quot;legs&quot;: 4,</span><br><span class="line">  &quot;tails&quot;: 1,</span><br><span class="line">  &quot;friends&quot;: [&quot;freeCodeCamp Campers&quot;]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">myDog.bark=&quot;woof&quot;;</span><br></pre></td></tr></table></figure>
<h1 id="删除对象的属性"><a href="#删除对象的属性" class="headerlink" title="删除对象的属性"></a>删除对象的属性</h1><p>我们同样可以删除对象的属性，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete ourDog.bark;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const ourDog = &#123;</span><br><span class="line">  &quot;name&quot;: &quot;Camper&quot;,</span><br><span class="line">  &quot;legs&quot;: 4,</span><br><span class="line">  &quot;tails&quot;: 1,</span><br><span class="line">  &quot;friends&quot;: [&quot;everything!&quot;],</span><br><span class="line">  &quot;bark&quot;: &quot;bow-wow&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">delete ourDog.bark;</span><br></pre></td></tr></table></figure>
<p>在上面代码的最后一行中，ourDog 是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;Camper&quot;,</span><br><span class="line">  &quot;legs&quot;: 4,</span><br><span class="line">  &quot;tails&quot;: 1,</span><br><span class="line">  &quot;friends&quot;: [&quot;everything!&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除对象的属性</p>
<p>删除 myDog 对象的 tails 属性。 可以使用点操作符或者中括号操作符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Setup</span><br><span class="line">const myDog = &#123;</span><br><span class="line">  &quot;name&quot;: &quot;Happy Coder&quot;,</span><br><span class="line">  &quot;legs&quot;: 4,</span><br><span class="line">  &quot;tails&quot;: 1,</span><br><span class="line">  &quot;friends&quot;: [&quot;freeCodeCamp Campers&quot;],</span><br><span class="line">  &quot;bark&quot;: &quot;woof&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// Only change code below this line</span><br><span class="line">delete myDog.tails;</span><br></pre></td></tr></table></figure>
<h1 id="操作复杂对象"><a href="#操作复杂对象" class="headerlink" title="操作复杂对象"></a>操作复杂对象</h1><p>有时你可能希望将数据存储在一个灵活的数据结构（Data Structure）中。 JavaScript 对象是一种灵活的数据结构。 它可以储存字符串（strings）、数字（numbers）、布尔值（booleans）、数组（arrays）、函数（functions）和对象（objects）以及这些值的任意组合。</p>
<p>这是一个复杂数据结构的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const ourMusic = [</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;artist&quot;: &quot;Daft Punk&quot;,</span><br><span class="line">    &quot;title&quot;: &quot;Homework&quot;,</span><br><span class="line">    &quot;release_year&quot;: 1997,</span><br><span class="line">    &quot;formats&quot;: [ </span><br><span class="line">      &quot;CD&quot;, </span><br><span class="line">      &quot;Cassette&quot;, </span><br><span class="line">      &quot;LP&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;gold&quot;: true</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>这是一个包含一个对象的数组。 该对象有关于专辑的各种元数据（metadata）。 它也有一个嵌套的 formats 数组。 可以将专辑添加到顶级数组来增加更多的专辑记录。 对象将数据以一种键 - 值对的形式保存。 在上面的示例中，”artist”: “Daft Punk” 有一个键为 artist 值为 Daft Punk 的属性。</p>
<p><strong>提示：</strong>数组中有多个 JSON 对象的时候，对象与对象之间要用逗号隔开。</p>
<p>操作复杂对象</p>
<p>添加一个新专辑到 myMusic 数组。 添加 artist 和 title 字符串，release_year 数字和 formats 字符串数组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">const myMusic = [</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;artist&quot;: &quot;Billy Joel&quot;,</span><br><span class="line">    &quot;title&quot;: &quot;Piano Man&quot;,</span><br><span class="line">    &quot;release_year&quot;: 1973,</span><br><span class="line">    &quot;formats&quot;: [</span><br><span class="line">      &quot;CD&quot;,</span><br><span class="line">      &quot;8T&quot;,</span><br><span class="line">      &quot;LP&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;gold&quot;: true</span><br><span class="line">  &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">    &quot;artist&quot;: &quot;Billy Joel 2&quot;,</span><br><span class="line">    &quot;title&quot;: &quot;Piano Man 2&quot;,</span><br><span class="line">    &quot;release_year&quot;: 1974,</span><br><span class="line">    &quot;formats&quot;: [</span><br><span class="line">      &quot;CD2&quot;,</span><br><span class="line">      &quot;8T2&quot;,</span><br><span class="line">      &quot;LP2&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;gold&quot;: true</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<h1 id="访问嵌套对象"><a href="#访问嵌套对象" class="headerlink" title="访问嵌套对象"></a>访问嵌套对象</h1><p>我们可以通过连续使用点号表示法和方括号表示法来访问对象的嵌套属性。</p>
<p>这是一个嵌套对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const ourStorage = &#123;</span><br><span class="line">  &quot;desk&quot;: &#123;</span><br><span class="line">    &quot;drawer&quot;: &quot;stapler&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;cabinet&quot;: &#123;</span><br><span class="line">    &quot;top drawer&quot;: &#123; </span><br><span class="line">      &quot;folder1&quot;: &quot;a file&quot;,</span><br><span class="line">      &quot;folder2&quot;: &quot;secrets&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;bottom drawer&quot;: &quot;soda&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ourStorage.cabinet[&quot;top drawer&quot;].folder2;</span><br><span class="line">ourStorage.desk.drawer;</span><br></pre></td></tr></table></figure>
<p>ourStorage.cabinet[“top drawer”].folder2 将会是字符串 secrets，并且 ourStorage.desk.drawer 将会是字符串 stapler。</p>
<p>访问嵌套对象</p>
<p>访问 myStorage 对象并将 glove box 属性的内容赋值给 gloveBoxContents 变量。 在可能的情况下，对所有的属性使用点号，否则使用方括号。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const myStorage = &#123;</span><br><span class="line">  &quot;car&quot;: &#123;</span><br><span class="line">    &quot;inside&quot;: &#123;</span><br><span class="line">      &quot;glove box&quot;: &quot;maps&quot;,</span><br><span class="line">      &quot;passenger seat&quot;: &quot;crumbs&quot;</span><br><span class="line">     &#125;,</span><br><span class="line">    &quot;outside&quot;: &#123;</span><br><span class="line">      &quot;trunk&quot;: &quot;jack&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const gloveBoxContents = myStorage.car.inside[&quot;glove box&quot;];</span><br></pre></td></tr></table></figure>

<h1 id="记录集合"><a href="#记录集合" class="headerlink" title="记录集合"></a>记录集合</h1><p>你将创建一个帮助维护音乐专辑集的函数。 这个集合是一个包含多个相册的对象，这些相册也是对象。 每张专辑在集合中以唯一的 id 作为属性名来表示。 在每个专辑对象中，有各种描述专辑信息的属性。 并非所有专辑都有完整的信息。</p>
<p>updateRecords 函数有 4 个参数，即以下参数：</p>
<p>records - 一个包含多个专辑的对象</p>
<p>id - 一个数字，代表 records 对象中特定的专辑</p>
<p>prop - 一个字符串，代表相册属性名称</p>
<p>value - 一个字符串，包含用来更新相册属性的信息</p>
<p>使用下面的规则完成函数来修改传递给函数的对象。</p>
<p>你的函数必须始终返回整个 records 对象。</p>
<p>如果 value 是空字符串，从专辑里删除指定的 prop。</p>
<p>如果 prop 不是 tracks，并且 value 不是一个空字符串，将 value 赋给那个专辑的 prop。</p>
<p>如果 prop 是 tracks 并且 value 不是一个空字符串，你需要更新专辑的 tracks 数组。</p>
<p> 首先，如果专辑没有 tracks 属性，赋予它一个空数组。 然后添加 value 作为专辑的 tracks 数组的最后一个项目。</p>
<p>注意： 将 recordCollection 对象的副本用于测试。 你不应该直接修改 recordCollection 对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// Setup</span><br><span class="line">const recordCollection = &#123;</span><br><span class="line">  2548: &#123;</span><br><span class="line">    albumTitle: &#x27;Slippery When Wet&#x27;,</span><br><span class="line">    artist: &#x27;Bon Jovi&#x27;,</span><br><span class="line">    tracks: [&#x27;Let It Rock&#x27;, &#x27;You Give Love a Bad Name&#x27;]</span><br><span class="line">  &#125;,</span><br><span class="line">  2468: &#123;</span><br><span class="line">    albumTitle: &#x27;1999&#x27;,</span><br><span class="line">    artist: &#x27;Prince&#x27;,</span><br><span class="line">    tracks: [&#x27;1999&#x27;, &#x27;Little Red Corvette&#x27;]</span><br><span class="line">  &#125;,</span><br><span class="line">  1245: &#123;</span><br><span class="line">    artist: &#x27;Robert Palmer&#x27;,</span><br><span class="line">    tracks: []</span><br><span class="line">  &#125;,</span><br><span class="line">  5439: &#123;</span><br><span class="line">    albumTitle: &#x27;ABBA Gold&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// Only change code below this line</span><br><span class="line">function updateRecords(records, id, prop, value) &#123;</span><br><span class="line">  if(value==&quot;&quot;)&#123;</span><br><span class="line">  delete records[id][prop];</span><br><span class="line">&#125;else if(prop!=&quot;tracks&quot;&amp;&amp;value!=&quot;&quot;)&#123;</span><br><span class="line">    records[id][prop]=value;</span><br><span class="line">&#125;else if(prop==&quot;tracks&quot;&amp;&amp;value!=&quot;&quot;)&#123;</span><br><span class="line">  if(records[id].hasOwnProperty(&quot;tracks&quot;)==false)&#123;</span><br><span class="line">    records[id][prop]=[];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  records[id][prop].push(value);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">  return records;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">updateRecords(recordCollection, 5439, &#x27;artist&#x27;, &#x27;ABBA&#x27;);</span><br></pre></td></tr></table></figure>
<h1 id="JavaScript-使用解构赋值操作对象"><a href="#JavaScript-使用解构赋值操作对象" class="headerlink" title="JavaScript 使用解构赋值操作对象"></a>JavaScript 使用解构赋值操作对象</h1><p>使用解构赋值来获取对象的值：</p>
<p>解构赋值是 ES6 引入的新语法，用来从数组和对象中提取值，并优雅地对变量进行赋值。</p>
<p>有如下 ES5 代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const user = &#123; name: &#x27;John Doe&#x27;, age: 34 &#125;;</span><br><span class="line"></span><br><span class="line">const name = user.name;</span><br><span class="line">const age = user.age;</span><br></pre></td></tr></table></figure>
<p>name 的值应该是字符串 John Doe， age 的值应该是数字 34。</p>
<p>下面是使用 ES6 解构赋值语句，实现相同效果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const &#123; name, age &#125; = user;</span><br></pre></td></tr></table></figure>
<p>同样，name 的值应该是字符串 John Doe， age 的值应该是数字 34。</p>
<p>在这里，自动创建 name 和 age 变量，并将 user 对象相应属性的值赋值给它们。 这个方法简洁多了。</p>
<p>你可以从对象中提取尽可能多或很少的值。</p>
<p>使用解构赋值从对象中分配变量：</p>
<p>可以给解构的值赋予一个新的变量名， 通过在赋值的时候将新的变量名放在冒号后面来实现。</p>
<p>还是以上个例子的对象来举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const user = &#123; name: &#x27;John Doe&#x27;, age: 34 &#125;;</span><br></pre></td></tr></table></figure>
<p>这是指定新的变量名的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const &#123; name: userName, age: userAge &#125; = user;</span><br></pre></td></tr></table></figure>
<p>你可以这么理解这段代码：获取 user.name 的值，将它赋给一个新的变量 userName，等等。 userName 的值将是字符串 John Doe，userAge 的值将是数字 34。</p>
<p>使用解构赋值从嵌套对象中分配变量：</p>
<p>你可以使用前两节课程中相同的原则来解构嵌套对象中的值。</p>
<p>使用与前面的例子中类似的对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const user = &#123;</span><br><span class="line">  johnDoe: &#123; </span><br><span class="line">    age: 34,</span><br><span class="line">    email: &#x27;johnDoe@freeCodeCamp.com&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这是解构对象的属性值赋值给具有相同名字的变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const &#123; johnDoe: &#123; age, email &#125;&#125; = user;</span><br></pre></td></tr></table></figure>
<p>这是将对象的属性值赋值给具有不同名字的变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const &#123; johnDoe: &#123; age: userAge, email: userEmail &#125;&#125; = user;</span><br></pre></td></tr></table></figure>
<p>JavaScript 使用解构赋值操作对象</p>
<p>将两个赋值语句替换成等价的解构赋值。 lowToday 和 highToday 应该为 LOCAL_FORECAST 中 today.low 和 today.high 的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const LOCAL_FORECAST = &#123;</span><br><span class="line">  yesterday: &#123; low: 61, high: 75 &#125;,</span><br><span class="line">  today: &#123; low: 64, high: 77 &#125;,</span><br><span class="line">  tomorrow: &#123; low: 68, high: 80 &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// Only change code below this line</span><br><span class="line">const &#123;today:&#123;low:lowToday,high:highToday&#125;&#125;=LOCAL_FORECAST</span><br><span class="line"></span><br><span class="line">// Only change code above this line</span><br></pre></td></tr></table></figure>
<h1 id="使用解构赋值从数组中分配变量"><a href="#使用解构赋值从数组中分配变量" class="headerlink" title="使用解构赋值从数组中分配变量"></a>使用解构赋值从数组中分配变量</h1><p>在 ES6 里面，解构数组可以如同解构对象一样简单。</p>
<p>与数组解构不同，数组的扩展运算会将数组里的所有内容分解成一个由逗号分隔的列表。 所以，你不能选择哪个元素来给变量赋值。</p>
<p>而对数组进行解构却可以让我们做到这一点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const [a, b] = [1, 2, 3, 4, 5, 6];</span><br><span class="line">console.log(a, b);</span><br></pre></td></tr></table></figure>
<p>控制台将显示 a 和 b 的值为 1, 2。</p>
<p>数组的第一个值被赋值给变量 a，数组的第二个值被赋值给变量 b。 我们甚至能在数组解构中使用逗号分隔符，来获取任意一个想要的值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const [a, b,,, c] = [1, 2, 3, 4, 5, 6];</span><br><span class="line">console.log(a, b, c);</span><br></pre></td></tr></table></figure>
<p>控制台将显示 a、b 和 c 的值为 1, 2, 5。</p>
<p>使用解构赋值从数组中分配变量</p>
<p>使用数组解构来交换变量 a 与 b 的值，使 a 接收 b 的值，而 b 接收 a 的值。 提示：将a和b组成一个数组，然后解构赋值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a = 8, b = 6;</span><br><span class="line">// Only change code below this line</span><br><span class="line"> [a,b]=[b,a];</span><br></pre></td></tr></table></figure>
<h1 id="通过-rest-参数解构"><a href="#通过-rest-参数解构" class="headerlink" title="通过 rest 参数解构"></a>通过 rest 参数解构</h1><p>在解构数组的某些情况下，我们可能希望将剩下的元素放进另一个数组里面。</p>
<p>以下代码的结果与使用 Array.prototype.slice() 类似：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const [a, b, ...arr] = [1, 2, 3, 4, 5, 7];</span><br><span class="line">console.log(a, b);</span><br><span class="line">console.log(arr);</span><br></pre></td></tr></table></figure>
<p>控制台将显示 1, 2 和 [3, 4, 5, 7]。</p>
<p>变量 a 和 b 分别接收数组的第一个和第二个值。 之后，因为 rest 语法，arr 以数组形式接收了剩余的值。 rest 参数只能对数组列表最后的元素起作用。 这意味着你不能使用 rest 语法来省略原数组最后一个元素、截取中间的元素作为子数组。</p>
<p>通过 rest 参数解构</p>
<p>使用一个带有 rest 语法的解构赋值来模拟 Array.prototype.slice() 的行为。 removeFirstTwo() 应该返回原始数组 list 的子数组，前两个元素被省略。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function removeFirstTwo(list) &#123;</span><br><span class="line">  const [,, ...arr] = list;</span><br><span class="line">  return arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const source = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];</span><br><span class="line">const sourceWithoutFirstTwo = removeFirstTwo(source);</span><br></pre></td></tr></table></figure>
<h1 id="JavaScript-解构赋值在函数参数中的基本用法"><a href="#JavaScript-解构赋值在函数参数中的基本用法" class="headerlink" title="JavaScript 解构赋值在函数参数中的基本用法"></a>JavaScript 解构赋值在函数参数中的基本用法</h1><p>解构赋值在函数参数中的基本用法：</p>
<p>在某些情况下，你可以在函数的参数里直接解构对象。</p>
<p>请看以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const profileUpdate = (profileData) =&gt; &#123;</span><br><span class="line">  const &#123; name, age, nationality, location &#125; = profileData;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的操作解构了传给函数的对象。 这样的操作也可以直接在参数里完成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const profileUpdate = (&#123; name, age, nationality, location &#125;) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 profileData 被传递到上面的函数时，从函数参数中解构出值以在函数内使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 使用数组解构赋值作为函数参数</span><br><span class="line">function printCoordinates([x, y]) &#123;</span><br><span class="line">    console.log(`Coordinates: ($&#123;x&#125;, $&#123;y&#125;)`);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const point = [3, 7];</span><br><span class="line">printCoordinates(point); // 输出 &quot;Coordinates: (3, 7)&quot;</span><br></pre></td></tr></table></figure>
<p>默认值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 使用数组解构赋值和默认值作为函数参数</span><br><span class="line">function greetUser([name = &#x27;Guest&#x27;]) &#123;</span><br><span class="line">    console.log(`Hello, $&#123;name&#125;!`);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greetUser([]); // 输出 &quot;Hello, Guest!&quot;</span><br><span class="line">// 使用对象解构赋值和默认值作为函数参数</span><br><span class="line">function greetPerson(&#123; name = &#x27;Guest&#x27;, age = 18 &#125;) &#123;</span><br><span class="line">    console.log(`Hello, $&#123;name&#125;! You are $&#123;age&#125; years old.`);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greetPerson(&#123;&#125;); // 输出 &quot;Hello, Guest! You are 18 years old.&quot;</span><br></pre></td></tr></table></figure>
<p>剩余操作符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 使用对象解构赋值和剩余操作符作为函数参数</span><br><span class="line">function printDetails(&#123; name, ...rest &#125;) &#123;</span><br><span class="line">    console.log(`Name: $&#123;name&#125;`);</span><br><span class="line">    console.log(&#x27;Additional details:&#x27;);</span><br><span class="line">    console.log(rest);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const person = &#123; name: &#x27;John&#x27;, age: 30, city: &#x27;New York&#x27; &#125;;</span><br><span class="line">printDetails(person);</span><br><span class="line">// 输出</span><br><span class="line">// Name: John</span><br><span class="line">// Additional details:</span><br><span class="line">// &#123; age: 30, city: &#x27;New York&#x27; &#125;</span><br></pre></td></tr></table></figure>
<p>JavaScript 解构赋值在函数参数中的基本用法</p>
<p>对 half 的参数进行解构赋值，仅将 max 与 min 的值传进函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const stats = &#123;</span><br><span class="line">  max: 56.78,</span><br><span class="line">  standard_deviation: 4.34,</span><br><span class="line">  median: 34.54,</span><br><span class="line">  mode: 23.87,</span><br><span class="line">  min: -0.75,</span><br><span class="line">  average: 35.85</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// Only change code below this line</span><br><span class="line">const half = (arr) =&gt; (arr.max + arr.min) / 2.0; </span><br><span class="line">//const half = (&#123;max,min&#125;) =&gt; (max + min) / 2.0; </span><br><span class="line"></span><br><span class="line">// Only change code above this line</span><br></pre></td></tr></table></figure>
<h1 id="JavaScript-深拷贝与浅拷贝"><a href="#JavaScript-深拷贝与浅拷贝" class="headerlink" title="JavaScript 深拷贝与浅拷贝"></a>JavaScript 深拷贝与浅拷贝</h1><p>在 JavaScript 中，深拷贝（Deep Copy）和浅拷贝（Shallow Copy）是常用的两种对象复制方式，它们在复制对象时有着不同的行为。</p>
<p>浅拷贝是指将一个值复制给一个新对象时，新对象的属性值是原始对象的引用，而不是原始对象的副本。因此，新对象与原始对象共享同一个引用类型的属性。</p>
<p>深拷贝是指将一个值复制给一个新对象时，新对象的属性值是原始对象属性的副本，而不是引用。因此，新对象与原始对象相互独立，修改一个对象不会影响另一个对象。</p>
<p>那么，哪些复制行为是浅拷贝，哪些赋值行为是深拷贝呢？以下是几种拷贝方式：</p>
<p>直接赋值：</p>
<p>在 JavaScript 中，直接赋值是一种浅拷贝的方式。这意味着对于原始类型数据，直接赋值会创建一个值的副本，而对于引用类型数据，直接赋值会创建一个新的引用，但是新旧引用指向的是同一个对象。因此，原始类型数据是浅拷贝，而引用类型数据也是浅拷贝。</p>
<p>原始数据类型：包括number、string、boolean、null 和 等。直接赋值会创建一个新的值的副本，修改副本不会影响原始值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let a = 10;</span><br><span class="line">let b = a;</span><br><span class="line">b = 20;</span><br><span class="line">console.log(a); // 输出 10，原始值不受影响</span><br></pre></td></tr></table></figure>

<p>引用类型数据：包括对象Object、数组Array、函数Function等。直接赋值会创建一个新的引用，但是新旧引用指向的是同一个对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let data1 = &#123;&quot;name&quot;:&quot;Alice&quot;,&quot;age&quot;:21&#125;</span><br><span class="line">let data2 = data1</span><br><span class="line"></span><br><span class="line">data2.name = &quot;Jack&quot;</span><br><span class="line"></span><br><span class="line">//改变data2，data1的数据也会相应改变</span><br><span class="line">console.log(data1)</span><br><span class="line">console.log(data2)</span><br><span class="line">//两者输出相同</span><br></pre></td></tr></table></figure>
<p><strong>浅拷贝的实现方式：</strong>浅拷贝只是拷贝一层，更深层次对象级别的只拷贝引用(地址)，所以改变新对象，旧对象也会改变，因为新旧对象共享一块内存。</p>
<p>通过 Object.assign() 拷贝</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const obj1 = &#123; a: 1, b: &#123; c: 2 &#125; &#125;;</span><br><span class="line">const obj2 = Object.assign(&#123;&#125;, obj1);</span><br><span class="line"></span><br><span class="line">obj2.a = 10;</span><br><span class="line">obj2.b.c = 20;</span><br><span class="line"></span><br><span class="line">console.log(obj1); // &#123; a: 1, b: &#123; c: 20 &#125; &#125;</span><br><span class="line">console.log(obj2); // &#123; a: 10, b: &#123; c: 20 &#125; &#125;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<p>当对象只有一级属性为深拷贝；<br>当对象中有多级属性时，二级属性后就是浅拷贝；</p>
<p><strong>深拷贝的实现：</strong>深拷贝的原理：复制并创建一个一模一样的对象，不共享内存，修改新对象，旧对象保持不变。</p>
<p>在 JavaScript 中实现深拷贝通常需要递归地遍历对象，并复制其属性及属性值。可以通过多种方式实现深拷贝，比如手动递归、使用 JSON.parse(JSON.stringify(obj))、使用第三方库等。</p>
<p>利用 JSON 对象实现深拷贝</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const obj1 = &#123; a: 1, b: &#123; c: 2 &#125; &#125;;</span><br><span class="line">const obj2 = JSON.parse(JSON.stringify(obj1));</span><br><span class="line"></span><br><span class="line">obj2.a = 10;</span><br><span class="line">obj2.b.c = 20;</span><br><span class="line"></span><br><span class="line">console.log(obj1); // &#123; a: 1, b: &#123; c: 2 &#125; &#125;</span><br><span class="line">console.log(obj2); // &#123; a: 10, b: &#123; c: 20 &#125; &#125;</span><br></pre></td></tr></table></figure>
<p>使用扩展运算符实现数组深拷贝</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a=[1,2,3]</span><br><span class="line">var b=[...a];</span><br><span class="line">b.push(4);</span><br><span class="line">console.log(b);//1,2,3,4</span><br><span class="line">console.log(a)//1,2,3</span><br></pre></td></tr></table></figure>
<p>JavaScript 深拷贝与浅拷贝</p>
<p>修改右侧代码，使得修改 obj2 的值时，obj1 的值不被修改</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const obj1 = &#123;a:1,b:2&#125;</span><br><span class="line"></span><br><span class="line">// Only change code below this line</span><br><span class="line">const obj2 = JSON.parse(JSON.stringify(obj1));</span><br><span class="line">// Only change code above this line</span><br><span class="line"></span><br><span class="line">obj2.a = 10</span><br><span class="line">obj2.b = 20</span><br><span class="line"></span><br><span class="line">console.log(obj1)</span><br><span class="line">console.log(obj2)</span><br></pre></td></tr></table></figure>

<h1 id="遍历数组-对象"><a href="#遍历数组-对象" class="headerlink" title="遍历数组&#x2F;对象"></a>遍历数组&#x2F;对象</h1><p>数组遍历 forEach ：</p>
<p>在 JavaScript 中，forEach() 是数组的一个高阶函数，用于遍历数组的每个元素，并对每个元素执行提供的回调函数。forEach() 方法不会改变原始数组，但允许对数组中的每个元素进行操作。</p>
<p>基本语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array.forEach(function(currentValue, index, array) &#123;</span><br><span class="line">    // 对当前元素执行的操作</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>currentValue：当前遍历的数组元素的值。</p>
<p>index：当前遍历的数组元素的索引。</p>
<p>array：调用 forEach() 方法的数组。</p>
<p>在前面的课程中，我们讲到了箭头函数，那么forEach也可以写成如下形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array.forEach((currentValue, index, array) =&gt; &#123;</span><br><span class="line">    // 对当前元素执行的操作</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const numbers = [1, 2, 3, 4, 5];</span><br><span class="line">let sum = 0;</span><br><span class="line"></span><br><span class="line">numbers.forEach(function(number, index) &#123;</span><br><span class="line">    console.log(`Index $&#123;index&#125;: $&#123;number&#125;`);</span><br><span class="line">    sum += number</span><br><span class="line">&#125;);</span><br><span class="line">console.log(`Sum: $&#123;sum&#125;`);</span><br><span class="line">// 输出：</span><br><span class="line">// Index 0: 1</span><br><span class="line">// Index 1: 2</span><br><span class="line">// Index 2: 3</span><br><span class="line">// Index 3: 4</span><br><span class="line">// Index 4: 5</span><br><span class="line">// Sum: 15</span><br></pre></td></tr></table></figure>
<p>数组遍历 map ：</p>
<p>在 JavaScript 中，map() 方法是数组对象的一个高阶函数，用于创建一个新数组，其中每个元素都是原始数组经过某种转换后的值。map() 方法会对数组中的每个元素都调用一个提供的函数，并将函数的返回值组成一个新数组返回，原始数组不受影响。</p>
<p>基本语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const newArray = array.map(function(currentValue, index, array) &#123;</span><br><span class="line">    // 返回新数组的每个元素</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>currentValue：当前遍历的数组元素的值。<br>index：当前遍历的数组元素的索引。<br>array：调用 map() 方法的数组。<br>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const numbers = [1, 2, 3, 4, 5];</span><br><span class="line"></span><br><span class="line">const doubledNumbers = numbers.map(function(number) &#123;</span><br><span class="line">    return number * 2;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(doubledNumbers); // 输出 [2, 4, 6, 8, 10]</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const names = [&#x27;Alice&#x27;, &#x27;Bob&#x27;, &#x27;Charlie&#x27;];</span><br><span class="line"></span><br><span class="line">const nameLengths = names.map(function(name) &#123;</span><br><span class="line">    return name.length;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(nameLengths); // 输出 [5, 3, 7]</span><br></pre></td></tr></table></figure>
<p>同样也可以使用箭头函数来简化 map() 方法的回调函数，使代码更加简洁。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const numbers = [1, 2, 3, 4, 5];</span><br><span class="line"></span><br><span class="line">const doubledNumbers = numbers.map(number =&gt; number * 2);</span><br><span class="line"></span><br><span class="line">console.log(doubledNumbers); // 输出 [2, 4, 6, 8, 10]</span><br></pre></td></tr></table></figure>
<p>注意事项：</p>
<p>map() 方法创建一个新数组，原始数组不受影响。</p>
<p>map() 方法中的回调函数可以访问当前元素的值、索引以及原始数组本身。</p>
<p>map() 方法返回的新数组的长度和原始数组相同。</p>
<p>map() 方法返回的新数组中的元素是根据原始数组中的每个元素经过回调函数处理后得到的结果。</p>
<p>在使用 map() 方法时，要确保回调函数不会修改原始数组的元素，因为 map() 方法创建的是一个新数组，而不是对原始数组的直接修改。</p>
<p>For&#x2F;In 循环： JavaScript for&#x2F;in 语句用来循环遍历对象的属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let person=&#123;fname:&quot;Bill&quot;,lname:&quot;Gates&quot;,age:56&#125;; </span><br><span class="line"> </span><br><span class="line">for (x in person)  // x 为属性名</span><br><span class="line">&#123;</span><br><span class="line">    txt=txt + person[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>for of 遍历可迭代对象：</p>
<p>在 JavaScript 中，for…of 循环是一种用于遍历可迭代对象（如数组、字符串、Map、Set 等）的语法结构。它提供了一种简洁、直观的方式来遍历可迭代对象的元素，相比传统的 for 循环和 forEach() 方法，for…of 更加灵活和方便。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//遍历数组</span><br><span class="line">const numbers = [1, 2, 3, 4, 5];</span><br><span class="line"></span><br><span class="line">for (const number of numbers) &#123;</span><br><span class="line">    console.log(number);</span><br><span class="line">&#125;</span><br><span class="line">// 输出：</span><br><span class="line">// 1</span><br><span class="line">// 2</span><br><span class="line">// 3</span><br><span class="line">// 4</span><br><span class="line">// 5</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//遍历字符串</span><br><span class="line">const str = &quot;Hello&quot;;</span><br><span class="line"></span><br><span class="line">for (const char of str) &#123;</span><br><span class="line">    console.log(char);</span><br><span class="line">&#125;</span><br><span class="line">// 输出：</span><br><span class="line">// H</span><br><span class="line">// e</span><br><span class="line">// l</span><br><span class="line">// l</span><br><span class="line">// o</span><br></pre></td></tr></table></figure>

<p>遍历数组&#x2F;对象</p>
<p>将对象 infoObj 中的所有值存在 infoArr 数组中，并且把 infoArr 中每个字符串的长度依次存在 lengthArr 中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">const infoObj = &#123;</span><br><span class="line">  &quot;id&quot;:&quot;123&quot;,</span><br><span class="line">  &quot;name&quot;:&quot;JavaScript&quot;,</span><br><span class="line">  &quot;avatar&quot;:&quot;Alice&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let infoArr = []</span><br><span class="line">let lengthArr = []</span><br><span class="line"></span><br><span class="line">// Only change code below this line</span><br><span class="line">for (x in infoObj)  // x 为属性名</span><br><span class="line">&#123;</span><br><span class="line">  infoArr.push(infoObj[x]);</span><br><span class="line">     //infoArr= infoArr + infoObj[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">     lengthArr= infoArr.map(function(name) &#123;</span><br><span class="line">    return name.length;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// Only change code below this line</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">console.log(infoArr)</span><br><span class="line">console.log(lengthArr)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="JavaScript-类的使用-类方法以及构造函数"><a href="#JavaScript-类的使用-类方法以及构造函数" class="headerlink" title="JavaScript 类的使用-类方法以及构造函数"></a>JavaScript 类的使用-类方法以及构造函数</h1><p>在 JavaScript 中，类是一种用于创建对象的蓝图或模板，它定义了对象的属性和方法。在 ES6（ECMAScript 2015）之前，JavaScript 并没有类的概念，而是通过构造函数和原型链来实现面向对象编程。ES6 引入了 class 关键字，使得在 JavaScript 中定义类更加直观和易于理解。</p>
<p><strong>定义：class 关键字：</strong>用特殊关键字 class 在 JavaScript 中定义一个类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">  // The body of class</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码定义了一个类 User。大括号 { } 界定了类的主体。请注意，此语法称为 类声明 。</p>
<p>当你创建类的 实例（instance） 时，该类将变得很有用。实例是一个包含类描述的数据和行为的对象。</p>
<p>new 运算符可在 JavaScript 中实例化该类：instance &#x3D; new Class()。</p>
<p>例如，你可以用 new 运算符实例化 User 类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const myUser = new User();</span><br></pre></td></tr></table></figure>
<p>构造方法：constructor()：</p>
<p>constructor(param1，param2，…) 是类中初始化实例的特殊方法。在这里你可以设置字段的初始值或针对对象进行任何类型的设置。</p>
<p>在以下示例中，构造函数设置了字段 name 的初始值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">  constructor(name,age) &#123;    </span><br><span class="line">      this.name = name;</span><br><span class="line">      this.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>User 的构造函数有参数 name和age，用于设置 this.name this.age字段的初始值。</p>
<p>在构造函数中，this 值等于新创建的实例。</p>
<p>用于实例化类的参数成为构造函数的参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">  constructor(name,age) &#123;  </span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const user1 = new User(&#x27;Jon Snow&#x27;,21);</span><br><span class="line">user1.name; // =&gt; &#x27;Jon Snow&#x27;</span><br><span class="line">user1.age;  // =&gt; 21</span><br></pre></td></tr></table></figure>
<p>那么在上例中，我们创建的user1对象就拥有name 为 Jon Snow，age 为 21的属性值；</p>
<p><strong>类方法：</strong>创建类方法的语法与对象方法相同。</p>
<p>请始终添加 constructor() 方法。</p>
<p>然后添加任意数量的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class ClassName &#123;</span><br><span class="line">  constructor() &#123; ... &#125;</span><br><span class="line">  method_1() &#123; ... &#125;</span><br><span class="line">  method_2() &#123; ... &#125;</span><br><span class="line">  method_3() &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JavaScript 类的使用-类方法以及构造函数</p>
<p>使用 class 关键词，写一个 constructor 来创建 Vegetable class。</p>
<p>Vegetable 这个 class 可以创建 vegetable 对象，这个对象拥有一个在 constructor 中赋值的 name 属性。</p>
<p>该类也应该有一个方法 getname 用来返回 The name of this vegetable is 后面跟上构造函数初始化的 name 属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// Only change code below this line</span><br><span class="line"></span><br><span class="line">class Vegetable&#123;</span><br><span class="line">    constructor(name)&#123;</span><br><span class="line">        this.name=name;</span><br><span class="line">         this.getname = function() &#123;  </span><br><span class="line">            return &quot;The name of this vegetable is &quot; + this.name;  </span><br><span class="line">        &#125;;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// Only change code above this line</span><br><span class="line"></span><br><span class="line">const carrot = new Vegetable(&#x27;carrot&#x27;);</span><br><span class="line">const tomato = new Vegetable(&#x27;tomato&#x27;);</span><br><span class="line">console.log(carrot.getname());</span><br><span class="line">console.log(tomato.getname());</span><br></pre></td></tr></table></figure>
<h1 id="JavaScript-类的使用-getter-和-setter-控制对象的访问"><a href="#JavaScript-类的使用-getter-和-setter-控制对象的访问" class="headerlink" title="JavaScript 类的使用 - getter 和 setter 控制对象的访问"></a>JavaScript 类的使用 - getter 和 setter 控制对象的访问</h1><p>你可以从对象中获得一个值，也可以给对象的属性赋值。</p>
<p>这些操作通常被称为 getters 以及 setters。</p>
<p>Getter 函数的作用是可以让对象返回一个私有变量，而不需要直接去访问私有变量。</p>
<p>Setter 函数的作用是可以基于传进的参数来修改对象中私有变量。 这些修改可以是计算，或者是直接替换之前的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Book &#123;</span><br><span class="line">  constructor(author) &#123;</span><br><span class="line">    this._author = author;</span><br><span class="line">  &#125;</span><br><span class="line">  // getter</span><br><span class="line">  get writer() &#123;</span><br><span class="line">    return this._author;</span><br><span class="line">  &#125;</span><br><span class="line">  // setter</span><br><span class="line">  set writer(updatedAuthor) &#123;</span><br><span class="line">    this._author = updatedAuthor;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const novel = new Book(&#x27;anonymous&#x27;);</span><br><span class="line">console.log(novel.writer);</span><br><span class="line">novel.writer = &#x27;newAuthor&#x27;;</span><br><span class="line">console.log(novel.writer);</span><br></pre></td></tr></table></figure>
<p>控制台将显示字符串 anonymous 和 newAuthor。</p>
<p>请注意用于调用 getter 和 setter 的语法。 它们甚至看起来不像是函数。 getter 和 setter 非常重要，因为它们隐藏了内部的实现细节。</p>
<p>注意： 通常会在私有变量前添加下划线（_）。 然而，这种做法本身并不是将变量变成私有的。</p>
<p>JavaScript 类的使用 - getter 和 setter 控制对象的访问</p>
<p>使用 class 关键字创建一个 Thermostat class。 constructor 接收一个华氏温度。</p>
<p>In the class, create a getter to obtain the temperature in Celsius and a setter that accepts a temperature in Celsius.</p>
<p>记得在 C &#x3D; 5&#x2F;9 * (F - 32) 和 F &#x3D; C * 9.0 &#x2F; 5 + 32 中，F 是华氏温度值，C 是摄氏温度值。</p>
<p>注意： 完成这个挑战后，应该在 class 中使用一个温度标准，要么是华氏温度，要么是摄氏温度。</p>
<p>这就是 getter 和 setter 的功能。 你正在为别的用户创建一个 API，不论你使用哪一个，用户都将获得正确的结果。</p>
<p>或者说，你从用户需求中抽象出了实现细节。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// Only change code below this line</span><br><span class="line">class Thermostat &#123;</span><br><span class="line">    constructor(F)</span><br><span class="line">    &#123;</span><br><span class="line">        this._F=F;</span><br><span class="line">    &#125;</span><br><span class="line">    // getter</span><br><span class="line">  get temperature() &#123;</span><br><span class="line">    return 5/9 * (this._F - 32);</span><br><span class="line">  &#125;</span><br><span class="line">  // setter</span><br><span class="line">  set temperature(C) &#123;</span><br><span class="line">     this._F = (9/5) * C + 32;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// Only change code above this line</span><br><span class="line"></span><br><span class="line">const thermos = new Thermostat(76); // Setting in Fahrenheit scale</span><br><span class="line">let temp = thermos.temperature; // 24.44 in Celsius</span><br><span class="line">thermos.temperature = 26;</span><br><span class="line">temp = thermos.temperature; // 26 in Celsius</span><br></pre></td></tr></table></figure>
<h1 id="JavaScript-类的使用-继承：extends"><a href="#JavaScript-类的使用-继承：extends" class="headerlink" title="JavaScript 类的使用 - 继承：extends"></a>JavaScript 类的使用 - 继承：extends</h1><p>继承：extends：</p>
<p>JavaScript 中的类用 extends 关键字支持单继承。</p>
<p>在表达式 class Child extends Parent { } 中，子类 child 从父类继承构造函数\字段和方法。</p>
<p>例如，让我们创建一个新的子类 ContentWriter， 来扩展父类 User。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">  name;</span><br><span class="line"></span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getName() &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ContentWriter extends User &#123;  </span><br><span class="line">    posts = [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const writer = new ContentWriter(&#x27;John Smith&#x27;);</span><br><span class="line"></span><br><span class="line">writer.name;      // =&gt; &#x27;John Smith&#x27;</span><br><span class="line">writer.getName(); // =&gt; &#x27;John Smith&#x27;</span><br><span class="line">writer.posts;     // =&gt; []</span><br></pre></td></tr></table></figure>
<p>ContentWriter 从 User 继承构造函数，getName() 方法和 name 字段。同样，ContentWriter 类声明一个新字段 posts。</p>
<p>注意，父类的私有成员不会被子类所继承。</p>
<p>父构造函数：constructor() 中的 super()：</p>
<p>如果你想在子类中调用父构的造函数，则需要使用子构造函数中提供的特殊功能 super()。</p>
<p>例如让 ContentWriter 构造函数调用 User 的父构造函数，并初始化 posts 字段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">  name;</span><br><span class="line"></span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getName() &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ContentWriter extends User &#123;</span><br><span class="line">  posts = [];</span><br><span class="line"></span><br><span class="line">  constructor(name, posts) &#123;</span><br><span class="line">    super(name);</span><br><span class="line">    this.posts = posts;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const writer = new ContentWriter(&#x27;John Smith&#x27;, [&#x27;Why I like JS&#x27;]);</span><br><span class="line">writer.name; // =&gt; &#x27;John Smith&#x27;</span><br><span class="line">writer.posts // =&gt; [&#x27;Why I like JS&#x27;]</span><br></pre></td></tr></table></figure>
<p>子类 ContentWriter 中的 super(name) 执行父类 User 的构造函数。</p>
<p>注意，在子构造函数内部，必须在使用 this 关键字之前执行 super()。调用 super() 确保父级构造函数初始化实例。</p>
<p>父实例：方法中的 super：</p>
<p>如果你想在子方法中访问父方法，则可以使用特殊的快捷方式 super。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">  name;</span><br><span class="line"></span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getName() &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ContentWriter extends User &#123;</span><br><span class="line">  posts = [];</span><br><span class="line"></span><br><span class="line">  constructor(name, posts) &#123;</span><br><span class="line">    super(name);</span><br><span class="line">    this.posts = posts;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getName() &#123;</span><br><span class="line">    const name = super.getName();    if (name === &#x27;&#x27;) &#123;</span><br><span class="line">      return &#x27;Unknwon&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    return name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const writer = new ContentWriter(&#x27;&#x27;, [&#x27;Why I like JS&#x27;]);</span><br><span class="line">writer.getName(); // =&gt; &#x27;Unknwon&#x27;</span><br></pre></td></tr></table></figure>
<p>子类 ContentWriter 的 getName() 直接从父类 User 访问方法 super.getName()。</p>
<p>JavaScript 类的使用 - 继承：extends</p>
<p>定义一个 rabbit 类，继承 animal 类，并且增加一个 color 属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class animal&#123;</span><br><span class="line">  name;</span><br><span class="line">  food;</span><br><span class="line">  </span><br><span class="line">  constructor(name,food) &#123;</span><br><span class="line">  	this.name = name;</span><br><span class="line">  	this.food = food;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  eat()&#123;</span><br><span class="line">    return `$&#123;this.name&#125; love to eat $&#123;this.food&#125;`;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  // Only change code below this line</span><br><span class="line">// 定义 rabbit 类，继承自 animal 类  </span><br><span class="line">class rabbit extends animal &#123;  </span><br><span class="line">  color;  </span><br><span class="line">  </span><br><span class="line">  // 构造函数需要调用 super 方法来初始化父类的属性  </span><br><span class="line">  constructor(name, food, color) &#123;  </span><br><span class="line">    super(name, food); // 调用父类的 constructor  </span><br><span class="line">    this.color = color; // 初始化自己的 color 属性  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  // 添加一个 getcolor 方法来获取兔子的颜色  </span><br><span class="line">  eat() &#123;  </span><br><span class="line">    return &quot;rabbit love to eat grass&quot;;  </span><br><span class="line">  &#125;  </span><br><span class="line"> getcolor() &#123;  </span><br><span class="line">    return `The color of this rabbit is $&#123;this.color&#125;`;  </span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line">  // Only change code above this line</span><br><span class="line"></span><br><span class="line">let a = new rabbit(&#x27;rabbit&#x27;,&#x27;grass&#x27;,&#x27;white&#x27;)</span><br><span class="line">console.log(a.eat())</span><br><span class="line">console.log(a.getcolor())</span><br></pre></td></tr></table></figure>

<h1 id="用-export-来重用代码块"><a href="#用-export-来重用代码块" class="headerlink" title="用 export 来重用代码块"></a>用 export 来重用代码块</h1><p>模块化的背景：</p>
<p>JavaScript 程序本来很小——在早期，它们大多被用来执行独立的脚本任务，在你的 web 页面需要的地方提供一定交互，所以一般不需要多大的脚本。过了几年，我们现在有了运行大量 JavaScript 脚本的复杂程序，还有一些被用在其他环境（例如 Node.js）。</p>
<p>因此，近年来，有必要开始考虑提供一种将 JavaScript 程序拆分为可按需导入的单独模块的机制。Node.js 已经提供这个能力很长时间了，还有很多的 JavaScript 库和框架已经开始了模块的使用（例如，CommonJS 和基于 AMD 的其他模块系统 如 RequireJS，以及最新的 Webpack 和 Babel）。</p>
<p>好消息是，最新的浏览器开始原生支持模块功能了，这是本文要重点讲述的。这会是一个好事情 —- 浏览器能够最优化加载模块，使它比使用库更有效率：使用库通常需要做额外的客户端处理。</p>
<p>导出模块的功能：</p>
<p>假设有一个文件 math_functions.js，该文件包含了数学运算相关的一些函数。 其中一个存储在变量 add 里，该函数接受两个数字作为参数返回它们的和。 你想在几个不同的 JavaScript 文件中使用这个函数。 要实现这个目的，就需要 export 它。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export const add = (x, y) =&gt; &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面是导出单个函数常用方法，还可以这样导出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const add = (x, y) =&gt; &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export &#123; add &#125;;</span><br></pre></td></tr></table></figure>
<p>导出变量和函数后，就可以在其它文件里导入使用从而避免了代码冗余。 重复第一个例子的代码可以导出多个对象或函数，在第二个例子里面的导出语句中添加更多值也可以导出多项，例子如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export &#123; add, subtract &#125;;</span><br></pre></td></tr></table></figure>
<p>用 export 来重用代码块</p>
<p>编辑框中有两个字符串相关的函数。 选用一种方法导出两个函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const uppercaseString = (string) =&gt; &#123;</span><br><span class="line">  return string.toUpperCase();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const lowercaseString = (string) =&gt; &#123;</span><br><span class="line">  return string.toLowerCase()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export &#123; uppercaseString, lowercaseString &#125;;</span><br></pre></td></tr></table></figure>
<h1 id="通过-import-复用-JavaScript-代码"><a href="#通过-import-复用-JavaScript-代码" class="headerlink" title="通过 import 复用 JavaScript 代码"></a>通过 import 复用 JavaScript 代码</h1><p>import 可以导入文件或模块的一部分。 在之前的课程里，例子从 math_functions.js 文件里导出了 add。 下面看一下如何在其它文件导入它：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; add &#125; from &#x27;./math_functions.js&#x27;;</span><br></pre></td></tr></table></figure>
<p>在这里，import 会在 math_functions.js 里找到 add，只导入这个函数，忽略剩余的部分。 .&#x2F; 告诉程序在当前文件的相同目录寻找 math_functions.js 文件。 用这种方式导入时，相对路径（.&#x2F;）和文件扩展名（.js）都是必需的。</p>
<p>通过在 import 语句里添加项目，可以从文件里导入多个项目，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; add, subtract &#125; from &#x27;./math_functions.js&#x27;;</span><br></pre></td></tr></table></figure>
<p>通过 import 复用 JavaScript 代码</p>
<p>添加 import 语句，使当前文件可以使用你在之前课程里导出的 uppercaseString 和 lowercaseString 函数。 函数在当前路径下的 string_functions.js 文件里。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// Only change code above this line</span><br><span class="line">import &#123; uppercaseString, lowercaseString  &#125; from &#x27;./string_functions.js&#x27;;</span><br><span class="line">uppercaseString(&quot;hello&quot;);</span><br><span class="line">lowercaseString(&quot;WORLD!&quot;);</span><br></pre></td></tr></table></figure>
<h1 id="用-从文件中导入所有内容"><a href="#用-从文件中导入所有内容" class="headerlink" title="用 * 从文件中导入所有内容"></a>用 * 从文件中导入所有内容</h1><p>假设你有一个文件，你希望将其所有内容导入到当前文件中。 可以用 import * as 语法来实现。 下面是一个从同目录下的 math_functions.js 文件中导入所有内容的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import * as myMathModule from &quot;./math_functions.js&quot;;</span><br></pre></td></tr></table></figure>
<p>上面的 import 语句会创建一个叫作 myMathModule 的对象。 这只是一个变量名，可以随便命名。 对象包含 math_functions.js 文件里的所有导出，可以像访问对象的属性那样访问里面的函数。 下面是使用导入的 add 和 subtract 函数的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myMathModule.add(2,3);</span><br><span class="line">myMathModule.subtract(5,3);</span><br></pre></td></tr></table></figure>
<p>用 * 从文件中导入所有内容</p>
<p>下面的代码需要从同目录下的 string_functions.js 文件中导入所有内容。 使用 import * as 语法将文件的所有内容导入对象 stringFunctions。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// Only change code above this line</span><br><span class="line">import * as stringFunctions from &quot;./string_functions.js&quot;;</span><br><span class="line">stringFunctions.uppercaseString(&quot;hello&quot;);</span><br><span class="line">stringFunctions.lowercaseString(&quot;WORLD!&quot;);</span><br></pre></td></tr></table></figure>

<h1 id="用-export-default-创建一个默认导出"><a href="#用-export-default-创建一个默认导出" class="headerlink" title="用 export default 创建一个默认导出"></a>用 export default 创建一个默认导出</h1><p>在 export 的课程中，你学习了命名导出语法， 这可以在其他文件中引用一些函数或者变量。</p>
<p>还需要了解另外一种被称为默认导出的 export 的语法。 在文件中只有一个值需要导出的时候，通常会使用这种语法。 它也常常用于给文件或者模块创建返回值。</p>
<p>下面是使用 export default 的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">export default function add(x, y) &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default function(x, y) &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个是命名函数，第二个是匿名函数。</p>
<p>export default 用于为模块或文件声明一个返回值，在每个文件或者模块中应当只默认导出一个值。 此外，你不能将 export default 与 var、let 或 const 同时使用。</p>
<p>用 export default 创建一个默认导出</p>
<p>下面的函数应该在这个模块中返回一个值。 请添加需要的代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function subtract(x, y) &#123;</span><br><span class="line">  return x - y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default function subtract(x, y) &#123;</span><br><span class="line">  return x - y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default function(x, y) &#123;</span><br><span class="line">  return x - y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="导入一个默认的导出"><a href="#导入一个默认的导出" class="headerlink" title="导入一个默认的导出"></a>导入一个默认的导出</h1><p>在上一个挑战里，学习了 export default 的用法。 还需要一种 import 的语法来导入默认的导出。 在下面的例子里，add 是 math_functions.js 文件的默认导出。 以下是如何导入它：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import add from &quot;./math_functions.js&quot;;</span><br></pre></td></tr></table></figure>
<p>这个语法有一处特别的地方， 被导入的 add 值没有被花括号（{}）所包围。 add 只是一个变量的名字，对应 math_functions.js 文件的任何默认导出值。 在导入默认导出时，可以使用任何名字。</p>
<p>导入一个默认的导出</p>
<p>在下面的代码中，导入同一目录中 math_functions.js 文件的默认导出。 导入变量的名字为 subtract。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import subtract from &quot;./math_functions.js&quot;;</span><br><span class="line">// 只修改这一行上面的代码</span><br><span class="line"></span><br><span class="line">subtract(7,4);</span><br></pre></td></tr></table></figure>

<h1 id="JavaScript-this指向"><a href="#JavaScript-this指向" class="headerlink" title="JavaScript this指向"></a>JavaScript this指向</h1><p>this的理解：</p>
<p>理解 JavaScript 中的 this 关键字是非常重要的，因为它在不同的上下文中具有不同的含义。this 的值取决于函数的调用方式，下面我们来详细解释不同情况下 this 的指向：</p>
<p>全局上下文中：在全局上下文中，即在任何函数外部，this 指向全局对象，通常在浏览器环境中指向 window 对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(this); // 输出 window（浏览器环境下）</span><br></pre></td></tr></table></figure>
<p>函数调用：当函数独立调用时，this 指向全局对象（在严格模式下是 ）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function myFunction() &#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myFunction(); // 输出 window（浏览器环境下）</span><br></pre></td></tr></table></figure>
<p>方法调用：当函数作为对象的方法调用时，this 指向调用该方法的对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;</span><br><span class="line">  name: &#x27;John&#x27;,</span><br><span class="line">  greet: function() &#123;</span><br><span class="line">    console.log(this.name); // 输出 John</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>obj.greet();<br>构造函数中：当函数用作构造函数使用（通过 new 关键字调用）时，this 指向新创建的对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Person(name) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const person1 = new Person(&#x27;Alice&#x27;);</span><br><span class="line">console.log(person1.name); // 输出 Alice</span><br></pre></td></tr></table></figure>
<p>class类中：在 JavaScript 的类（class）中，this 的行为也与其他情况有所不同。在类中，this 指向实例化的对象，也就是类的实例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  greet() &#123;</span><br><span class="line">    console.log(`Hello, $&#123;this.name&#125;`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const person1 = new Person(&#x27;Alice&#x27;);</span><br><span class="line">person1.greet(); // 输出 Hello, Alice</span><br></pre></td></tr></table></figure>
<p>在这个例子中，this 关键字在 Person 类的构造函数和 greet 方法中都指向实例化的对象 person1。因此，当调用 person1.greet() 时，this 指向 person1 对象，从而输出相应的问候语。 需要注意的是，如果在类的方法中使用普通的函数，那么函数内部的 this 将会丢失其上下文，并可能指向全局对象或者 ，这时需要使用箭头函数来绑定正确的上下文：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  greet() &#123;</span><br><span class="line">    setTimeout(function() &#123;</span><br><span class="line">      console.log(`Hello, $&#123;this.name&#125;`); // 此处的 this 指向全局对象（在浏览器环境中通常是 window）</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const person1 = new Person(&#x27;Alice&#x27;);</span><br><span class="line">person1.greet(); // 输出 &quot;Hello, &quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  greet() &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      console.log(`Hello, $&#123;this.name&#125;`); // 将普通函数改为箭头函数，this重新指向Person实例</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const person1 = new Person(&#x27;Alice&#x27;);</span><br><span class="line">person1.greet(); // 输出 &quot;Hello, Alice&quot;</span><br></pre></td></tr></table></figure>
<p>通过箭头函数，我们将内部函数绑定到了外部函数的上下文，确保了 this 指向正确的对象。</p>
<p>JavaScript this指向</p>
<p>更改代码，使其能够正确调用greet方法，输出Hello, John</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;</span><br><span class="line">  name: &#x27;John&#x27;,</span><br><span class="line">  greet: function() &#123;</span><br><span class="line">    console.log(`Hello, $&#123;this.name&#125;`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// Only change code below this line</span><br><span class="line">//const greetFunction = obj.greet;</span><br><span class="line">obj.greet();</span><br><span class="line">const greetFunction = obj.greet.bind(obj); </span><br><span class="line">greetFunction();</span><br><span class="line">// Only change code above this line</span><br></pre></td></tr></table></figure>

<h1 id="JavaScript-闭包"><a href="#JavaScript-闭包" class="headerlink" title="JavaScript 闭包"></a>JavaScript 闭包</h1><p>闭包是 JavaScript 中一个重要且常见的概念，它是指函数和其词法环境的组合。在理解闭包之前，我们需要先了解一下 JavaScript 中的词法作用域和作用域链。</p>
<p>词法作用域：</p>
<p>JavaScript 使用词法作用域（也称为静态作用域），即作用域由代码中函数声明的位置决定。这意味着在函数内部可以访问外部函数定义的变量，但是外部函数不能访问内部函数的变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function outerFunction() &#123;</span><br><span class="line">  const outerVariable = &#x27;I am outer!&#x27;;</span><br><span class="line">  </span><br><span class="line">  function innerFunction() &#123;</span><br><span class="line">    console.log(outerVariable); // 内部函数可以访问外部函数的变量</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  innerFunction();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">outerFunction(); // 输出 &quot;I am outer!&quot;</span><br></pre></td></tr></table></figure>
<p>闭包的概念：</p>
<p>闭包就是函数和其词法环境的组合，它允许函数访问其外部作用域中的变量，即使函数在外部作用域执行完毕后仍然能够访问这些变量。换句话说，闭包使函数拥有了“记忆力”，可以记住创建它的上下文。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function outerFunction() &#123;</span><br><span class="line">  const outerVariable = &#x27;I am outer!&#x27;;</span><br><span class="line">  </span><br><span class="line">  function innerFunction() &#123;</span><br><span class="line">    console.log(outerVariable); // 内部函数可以访问外部函数的变量</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return innerFunction;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const inner = outerFunction();</span><br><span class="line">inner(); // 输出 &quot;I am outer!&quot;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，innerFunction 是一个闭包，它可以访问外部函数 outerFunction 中的变量 outerVariable。即使 outerFunction 执行完毕，innerFunction 依然可以访问到 outerVariable。</p>
<p>属性私有化：</p>
<p>使属性私有化最简单的方法就是在构造函数中创建变量。 可以将该变量范围限定在构造函数中，而不是全局可用。 这样，属性只能由构造函数中的方法访问和更改。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Bird() &#123;</span><br><span class="line">  let hatchedEgg = 10;</span><br><span class="line"></span><br><span class="line">  this.getHatchedEggCount = function() &#123; </span><br><span class="line">    return hatchedEgg;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">let ducky = new Bird();</span><br><span class="line">ducky.getHatchedEggCount();</span><br></pre></td></tr></table></figure>
<p>这里的 getHatchedEggCount 是一种特权方法，因为它可以访问私有属性 hatchedEgg。 这是因为 hatchedEgg 是在与 getHatchedEggCount 相同的上下文中声明的。 在 JavaScript 中，函数总是可以访问创建它的上下文。 这就叫做 closure。</p>
<p>闭包的应用：</p>
<p>闭包在 JavaScript 中有许多应用场景，常见的包括隐藏数据、封装代码、模块化开发等。例如，可以使用闭包来创建私有变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function createCounter() &#123;</span><br><span class="line">  let count = 0;</span><br><span class="line"></span><br><span class="line">  return &#123;</span><br><span class="line">    increment: function() &#123;</span><br><span class="line">      count++;</span><br><span class="line">      console.log(count);</span><br><span class="line">    &#125;,</span><br><span class="line">    decrement: function() &#123;</span><br><span class="line">      count--;</span><br><span class="line">      console.log(count);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const counter = createCounter();</span><br><span class="line">counter.increment(); // 输出 1</span><br><span class="line">counter.increment(); // 输出 2</span><br><span class="line">counter.decrement(); // 输出 1</span><br></pre></td></tr></table></figure>
<p>在这个例子中，createCounter 函数返回一个包含 increment 和 decrement 方法的对象，这些方法都可以访问 createCounter 函数中的 count 变量，但是外部无法直接访问 count 变量。这样就实现了私有变量的效果。</p>
<p>总之，闭包是 JavaScript 中一个非常有用且强大的特性，它使得函数拥有了持久性的状态，并且可以访问其外部作用域中的变量，从而实现了许多有趣的功能和模式。</p>
<p>JavaScript 闭包</p>
<p>更改在 Bird 函数中声明的 weight 方法，使其成为私有变量。 然后，创建一个返回 weight 值 15 的 getWeight 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function Bird() &#123;  </span><br><span class="line">  // 使用let或const来声明私有变量  </span><br><span class="line">  let weight = 15;// 这里是私有的  </span><br><span class="line">  </span><br><span class="line">  // 返回一个对象，其中包含访问私有变量的公有方法  </span><br><span class="line">  return &#123;  </span><br><span class="line">    getWeight: function() &#123;  </span><br><span class="line">      return weight;  </span><br><span class="line">    &#125;  </span><br><span class="line">    // 如果需要，还可以添加其他方法或属性，它们都可以访问这个私有的weight变量  </span><br><span class="line">  &#125;;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">// 使用Bird函数  </span><br><span class="line">//const myBird = Bird();  </span><br><span class="line">//console.log(myBird.getWeight()); // 输出: 15  </span><br><span class="line">  </span><br><span class="line">// 注意：你不能直接访问myBird.weight，因为它没有在Bird函数返回的对象中定义，所以是“私有”的  </span><br><span class="line">//console.log(myBird.weight); // 这将输出undefined，因为weight是私有的</span><br></pre></td></tr></table></figure>

<h1 id="JavaScript-bind，apply，call"><a href="#JavaScript-bind，apply，call" class="headerlink" title="JavaScript bind，apply，call"></a>JavaScript bind，apply，call</h1><p>改变this指向：</p>
<p>bind，call，apply的作用都是用来改变this指向的，那为什么要改变this指向呢？请看下面的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var name=&quot;lucy&quot;;</span><br><span class="line">let obj=&#123;</span><br><span class="line"> name:&quot;martin&quot;,</span><br><span class="line"> say:function () &#123;</span><br><span class="line"> 	console.log(this.name);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.say(); //martin，this指向obj对象</span><br><span class="line">setTimeout(obj.say,0); //lucy，this指向window对象</span><br></pre></td></tr></table></figure>
<p>可以观察到，正常情况下 say 方法中的this是指向调用它的 obj 对象的，而定时器 setTimeout 中的 say 方法中的 this 是指向window对象的(在浏览器中)，这是因为 say 方法在定时器中是作为回调函数来执行的，因此回到主栈执行时是在全局执行上下文的环境中执行的，但我们需要的是 say 方法中 this 指向obj对象，因此我们需要修改 this 的指向。</p>
<p>apply方法：apply接受两个参数，第一个参数是this的指向，第二个参数是函数接受的参数，以数组的形式传入，且当第一个参数为null、的时候，默认指向window(在浏览器中)，使用apply方法改变this指向后原函数会立即执行，且此方法只是临时改变thi指向一次。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var name=&quot;martin&quot;;</span><br><span class="line">var obj=&#123;</span><br><span class="line"> name:&quot;lucy&quot;,</span><br><span class="line"> say:function(year,place)&#123;</span><br><span class="line"> 	console.log(this.name+&quot; is &quot;+year+&quot; born from &quot;+place);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var say=obj.say;</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line"> say.apply(obj,[&quot;1996&quot;,&quot;China&quot;])</span><br><span class="line">&#125; ,0); //lucy is 1996 born from China,this改变指向了obj</span><br><span class="line">say(&quot;1996&quot;，&quot;China&quot;) //martin is 1996 born from China,this指向window，说明apply只是临时改变一次this指向</span><br></pre></td></tr></table></figure>
<p><strong>call方法：</strong>call方法的第一个参数也是this的指向，后面传入的是一个参数列表（注意和apply传参的区别）。当一个参数为null或的时候，表示指向window（在浏览器中），和apply一样，call也只是临时改变一次this指向，并立即执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function.call(thisArg, arg1, arg2, ...);</span><br></pre></td></tr></table></figure>
<p>bind方法：bind方法和call很相似，第一参数也是this的指向，后面传入的也是一个参数列表(但是这个参数列表可以分多次传入，call则必须一次性传入所有参数。</p>
<p>bind 方法会创建一个新的函数，并将指定的对象绑定为函数执行时的上下文。该方法不会立即调用函数，而是返回一个新的函数，你可以稍后调用这个新函数。bind 方法的基本用法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let obj=&#123;</span><br><span class="line"> name:&quot;martin&quot;,</span><br><span class="line"> say:function () &#123;</span><br><span class="line"> 	console.log(this.name);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let obj2 = &#123;</span><br><span class="line"> name:&quot;bob&quot;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let bound = obj.say.bind(obj2)</span><br><span class="line">bound()</span><br></pre></td></tr></table></figure>
<p>apply，call，bind三者的区别：</p>
<p>三者都可以改变函数的this对象指向。</p>
<p>三者第一个参数都是this要指向的对象，如果如果没有这个参数或参数为或null，则默认指向全局window。</p>
<p>三者都可以传参，但是apply是数组，而call是参数列表，且apply和call是一次性传入参数，而bind可以分为多次传入。</p>
<p>bind 是返回绑定this之后的函数，便于稍后调用；apply 、call 则是立即执行 。</p>
<p>JavaScript bind，apply，call</p>
<p>修改指定行代码，使用 bind 改变 this 指向,使其正常代码执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let module = &#123;</span><br><span class="line">  x: 42,</span><br><span class="line">  getX: function () &#123;</span><br><span class="line">    return this.x;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let unboundGetX = module.getX;</span><br><span class="line">let boundGetX=unboundGetX.bind(module);;// Change this line</span><br><span class="line">console.log(boundGetX());</span><br></pre></td></tr></table></figure>
<h1 id="JavaScript-回调函数"><a href="#JavaScript-回调函数" class="headerlink" title="JavaScript 回调函数"></a>JavaScript 回调函数</h1><p>在JavaScript中，回调函数是一种常见的编程模式，用于处理异步操作和事件处理。回调函数是作为参数传递给另一个函数，当某个特定的事件发生或异步操作完成时，该回调函数会被调用执行。</p>
<p>下面详细讲解一下JavaScript中回调函数的特点、用法和示例：</p>
<p>特点：</p>
<p>回调函数是一种函数类型的值。<br>回调函数作为参数传递给其他函数，以便在特定的事件发生时调用。<br>回调函数通常用于处理异步操作的结果或处理事件响应。<br>用法：</p>
<p>处理异步操作：当需要处理耗时的操作（例如网络请求、文件读取等）时，可以将回调函数作为异步操作的回调，在操作完成后执行。<br>事件处理：在事件驱动的编程中，可以将回调函数注册为事件的处理函数，在事件发生时执行。<br>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 处理异步操作</span><br><span class="line">function fetchData(url, callback) &#123;</span><br><span class="line">    // 模拟异步操作，延迟1秒钟</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        // 模拟获取数据</span><br><span class="line">        let data = &#123; id: 1, name: &#x27;John&#x27; &#125;;</span><br><span class="line">        // 调用回调函数并传递数据</span><br><span class="line">        callback(data);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line">//使用箭头函数传入，获取到数据后，执行打印数据操作</span><br><span class="line">fetchData(&#x27;https://example.com/data&#x27;, res =&gt;&#123;</span><br><span class="line">    console.log(&quot;Get Data：&quot; , res)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在这个示例中，回调函数 res&#x3D;&gt;{} 用于处理异步操作 fetchData 的结果，回调函数在异步操作完成后被调用。另外，回调函数也被用作事件处理函数，在按钮点击事件发生时执行。</p>
<p>JavaScript 回调函数</p>
<p>fetchData 函数用于模拟查询包含name的数据，并且将数据返回给回调函数中，请完成指定行代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function fetchData(name, callback) &#123;</span><br><span class="line">	const data = [</span><br><span class="line">      &#123;name:&quot;zhang&quot;,stuID:&quot;S234&quot;&#125;,</span><br><span class="line">      &#123;name:&quot;shen&quot;,stuID:&quot;S235&quot;&#125;,</span><br><span class="line">      &#123;name:&quot;liu&quot;,stuID:&quot;S236&quot;&#125;,</span><br><span class="line">    ]</span><br><span class="line">  </span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      let i = 0</span><br><span class="line">      for(;i&lt;data.length;i++)&#123;</span><br><span class="line">        if(data[i].name == name)&#123;</span><br><span class="line">         callback(data[i]); </span><br><span class="line">        break; // 退出循环  </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      if(i == data.length) callback(&quot;没有查到包含&quot;+ name +&quot;的数据~&quot;);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fetchData(&quot;zhang&quot;,res=&gt;&#123;</span><br><span class="line">	console.log(res)</span><br><span class="line">&#125;)</span><br><span class="line">fetchData(&quot;wang&quot;,res=&gt;&#123;</span><br><span class="line">	console.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="创建一个-JavaScript-Promise"><a href="#创建一个-JavaScript-Promise" class="headerlink" title="创建一个 JavaScript Promise"></a>创建一个 JavaScript Promise</h1><p>Promise 是异步编程的一种解决方案 - 它在未来的某时会生成一个值。 任务完成，分执行成功和执行失败两种情况。 Promise 是构造器函数，需要通过 new 关键字来创建。 构造器参数是一个函数，该函数有两个参数 - resolve 和 reject。 通过它们来判断 promise 的执行结果。 用法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const myPromise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>创建一个 JavaScript Promise</p>
<p>创建一个名为 makeServerRequest 的 promise。 给构造器函数传入 resolve 和 reject 两个参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const makeServerRequest = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="通过-resolve-和-reject-完成-Promise"><a href="#通过-resolve-和-reject-完成-Promise" class="headerlink" title="通过 resolve 和 reject 完成 Promise"></a>通过 resolve 和 reject 完成 Promise</h1><p>ES6中的Promise是一种用于处理异步操作的对象，它代表了一个异步操作的最终完成或失败，以及其结果值。Promise对象有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。当Promise对象的状态从pending转变为fulfilled或rejected时，将会执行相应的回调函数。</p>
<p>上一个挑战里创建的 promise 一直阻塞在 pending 状态里，因为没有调用 promise 的完成方法。 Promise 提供的 resolve 和 reject 参数就是用来结束 promise 的。 Promise 成功时调用 resolve，promise 执行失败时调用 reject， 如下文所述，这些方法需要有一个参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const myPromise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  if(condition here) &#123;</span><br><span class="line">    resolve(&quot;Promise was fulfilled&quot;);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    reject(&quot;Promise was rejected&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面的示例使用字符串作为这些函数的参数，但参数实际上可以是任何格式。 通常，它可能是一个包含数据的对象，你可以将它放在网站或其他地方。</p>
<p>通过 resolve 和 reject 完成 Promise</p>
<p>使 promise 可以处理成功和失败情况。 如果 responseFromServer 是 true，调用 resolve 方法使 promise 成功。 给 resolve 传递值为 We got the data 的字符串。 如果 responseFromServer 是 false， 使用 reject 方法并传入值为 Data not received 的字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const makeServerRequest = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  </span><br><span class="line">  let responseFromServer = true;</span><br><span class="line"></span><br><span class="line">  if(responseFromServer) &#123;</span><br><span class="line">    resolve(&quot;We got the data&quot;);</span><br><span class="line">  &#125; else &#123;  </span><br><span class="line">    reject(&quot;Data not received&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="用-then-处理-Promise-完成的情况"><a href="#用-then-处理-Promise-完成的情况" class="headerlink" title="用 then 处理 Promise 完成的情况"></a>用 then 处理 Promise 完成的情况</h1><p>当程序需要花费未知的时间才能完成时（比如一些异步操作），一般是服务器请求，promise 很有用。 服务器请求会花费一些时间，当结束时，需要根据服务器的响应执行一些操作。 这可以用 then 方法来实现， 当 promise 完成 resolve 时会触发 then 方法。 例子如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myPromise.then(result =&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>result 即传入 resolve 方法的参数。</p>
<p>用 then 处理 Promise 完成的情况</p>
<p>给 promise 添加 then 方法。 用 result 做为回调函数的参数并将 result 打印在控制台。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const makeServerRequest = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  // responseFromServer is set to true to represent a successful response from a server</span><br><span class="line">  let responseFromServer = true;</span><br><span class="line"></span><br><span class="line">  if(responseFromServer) &#123;</span><br><span class="line">    resolve(&quot;We got the data&quot;);</span><br><span class="line">  &#125; else &#123;  </span><br><span class="line">    reject(&quot;Data not received&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">makeServerRequest.then(  </span><br><span class="line">  (result) =&gt; &#123;  </span><br><span class="line">    // 当Promise被解析时，这个回调函数会被调用  </span><br><span class="line">    // result参数包含了Promise解析后的值  </span><br><span class="line">    console.log(result); // 打印结果到控制台  </span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h1 id="使用-catch-处理-Promise-失败的情况"><a href="#使用-catch-处理-Promise-失败的情况" class="headerlink" title="使用 catch 处理 Promise 失败的情况"></a>使用 catch 处理 Promise 失败的情况</h1><p>当 promise 失败时会调用 catch 方法。 当 promise 的 reject 方法执行时会直接调用。 用法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myPromise.catch(error =&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>error 是传入 reject 方法的参数。</p>
<p>使用 catch 处理 Promise 失败的情况</p>
<p>给 promise 添加 catch 方法。 用 error 作为回调函数的参数，并把 error 打印到控制台。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const makeServerRequest = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  // responseFromServer is set to false to represent an unsuccessful response from a server</span><br><span class="line">  let responseFromServer = false;</span><br><span class="line"></span><br><span class="line">  if(responseFromServer) &#123;</span><br><span class="line">    resolve(&quot;We got the data&quot;);</span><br><span class="line">  &#125; else &#123;  </span><br><span class="line">    reject(&quot;Data not received&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">makeServerRequest.then(result =&gt; &#123;</span><br><span class="line">  console.log(result);</span><br><span class="line">&#125;).catch(error =&gt; &#123;</span><br><span class="line">  console.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="Promise-进阶"><a href="#Promise-进阶" class="headerlink" title="Promise 进阶"></a>Promise 进阶</h1><p>Promise链：</p>
<p>前面讲完了Promise的基础用法，Promise对象也可以链式调用，每个 then() 或 catch() 方法都可以返回一个新的Promise对象，因此可以串联多个异步操作。这种机制被称为Promise链。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">let myPromise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    if(true)&#123;</span><br><span class="line">        resolve(&#x27;Step 1 data&#x27;)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        reject(&#x27;Caught error&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">myPromise.then((data) =&gt; &#123;</span><br><span class="line">    console.log(&#x27;Step 1:&#x27;, data);</span><br><span class="line">    return &#x27;Step 2 data&#x27;;</span><br><span class="line">&#125;).then((data) =&gt; &#123;</span><br><span class="line">    console.log(&#x27;Step 2:&#x27;, data);</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            resolve(&#x27;Step 3 data&#x27;);</span><br><span class="line">        &#125;, 1000);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;).then((data) =&gt; &#123;</span><br><span class="line">    console.log(&#x27;Step 3:&#x27;, data);</span><br><span class="line">&#125;).catch((error) =&gt; &#123;</span><br><span class="line">    console.log(&#x27;Caught error:&#x27;, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在这个例子中，每个 then() 返回的是一个新的Promise对象，可以在其中执行新的异步操作，并在下一个 then() 中处理其结果。</p>
<p>Promise.all() 和 Promise.race()：</p>
<p>Promise.all() 接收一个Promise数组作为参数，当所有Promise都成功时，返回一个包含所有Promise结果的数组；如果任何一个Promise失败，立即返回失败状态。</p>
<p>Promise.race() 接收一个Promise数组作为参数，返回第一个完成的Promise的结果或失败原因。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let promise1 = Promise.resolve(&#x27;Promise 1&#x27;);</span><br><span class="line">let promise2 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        resolve(&#x27;Promise 2&#x27;);</span><br><span class="line">    &#125;, 2000);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Promise.all([promise1, promise2]).then((values) =&gt; &#123;</span><br><span class="line">    console.log(&#x27;All promises resolved:&#x27;, values);</span><br><span class="line">&#125;).catch((error) =&gt; &#123;</span><br><span class="line">    console.log(&#x27;Error:&#x27;, error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Promise.race([promise1, promise2]).then((value) =&gt; &#123;</span><br><span class="line">    console.log(&#x27;First promise resolved:&#x27;, value);</span><br><span class="line">&#125;).catch((error) =&gt; &#123;</span><br><span class="line">    console.log(&#x27;Error:&#x27;, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Promise 进阶</p>
<p>使用 Promise.all 和 Promise.race 函数，参数传入 promise1 和 promise2，打印结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let promise1 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        resolve(&#x27;Promise 1 Data&#x27;);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">&#125;);</span><br><span class="line">let promise2 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        resolve(&#x27;Promise 2 Data&#x27;);</span><br><span class="line">    &#125;, 2000);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Promise.all([promise1, promise2]).then((values) =&gt; &#123;</span><br><span class="line">    console.log(&#x27;All promises resolved:&#x27;, values);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Promise.race([promise1, promise2]).then((value) =&gt; &#123;</span><br><span class="line">    console.log(&#x27;First promise resolved:&#x27;, value);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>








</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">晚风温柔苍生</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/07/13/JavaScript/">http://example.com/2024/07/13/JavaScript/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">晚风的喵喵屋吖</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/index%20img.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.png" target="_blank"><img class="post-qr-code-img" src="/img/wechat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/07/15/jQuery%E6%A1%86%E6%9E%B6(DOM)/" title="jQuery框架(DOM)"><img class="cover" src="/img/index%20img.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">jQuery框架(DOM)</div></div></a></div><div class="next-post pull-right"><a href="/2024/07/12/flexbox%E5%B8%83%E5%B1%80/" title="flexbox布局"><img class="cover" src="/img/index%20img.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">flexbox布局</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/favicon.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">晚风温柔苍生</div><div class="author-info__description">我是晚风吖~</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%99%E4%BB%A3%E7%A0%81%E6%B7%BB%E5%8A%A0%E6%B3%A8%E9%87%8A"><span class="toc-number">1.</span> <span class="toc-text">给代码添加注释</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#let%E4%B8%8Econst"><span class="toc-number">2.</span> <span class="toc-text">let与const</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%90%86%E8%A7%A3%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E5%8F%98%E9%87%8F"><span class="toc-number">3.</span> <span class="toc-text">理解未初始化的变量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#js%E4%B8%83%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.</span> <span class="toc-text">js七种数据类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%A8%A1%E6%9D%BF%E5%AD%97%E9%9D%A2%E9%87%8F%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">5.</span> <span class="toc-text">使用模板字面量创建字符串</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-JavaScript-%E6%95%B0%E7%BB%84%E5%B0%86%E5%A4%9A%E4%B8%AA%E5%80%BC%E5%AD%98%E5%82%A8%E5%9C%A8%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F%E4%B8%AD"><span class="toc-number">6.</span> <span class="toc-text">使用 JavaScript 数组将多个值存储在一个变量中</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%94%A8%E5%87%BD%E6%95%B0%E7%BC%96%E5%86%99%E5%8F%AF%E9%87%8D%E7%94%A8%E4%BB%A3%E7%A0%81"><span class="toc-number">7.</span> <span class="toc-text">用函数编写可重用代码</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B0%86%E5%80%BC%E4%BC%A0%E9%80%92%E7%BB%99%E5%B8%A6%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">8.</span> <span class="toc-text">将值传递给带有参数的函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JavaScript-%E5%87%BD%E6%95%B0%E7%9A%84%E5%80%BC%E4%BC%A0%E9%80%92%E4%B8%8E%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92"><span class="toc-number">9.</span> <span class="toc-text">JavaScript 函数的值传递与引用传递</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-return-%E7%BB%99%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">10.</span> <span class="toc-text">使用 return 给函数返回值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E7%BC%96%E5%86%99%E7%AE%80%E6%B4%81%E7%9A%84%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"><span class="toc-number">11.</span> <span class="toc-text">使用箭头函数编写简洁的匿名函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="toc-number">12.</span> <span class="toc-text">编写带参数的箭头函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%94%A8-ES6-%E7%BC%96%E5%86%99%E7%AE%80%E6%B4%81%E7%9A%84%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E"><span class="toc-number">13.</span> <span class="toc-text">用 ES6 编写简洁的函数声明</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8Cwindow"><span class="toc-number">14.</span> <span class="toc-text">全局作用域和window</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%87%BD%E6%95%B0"><span class="toc-number">15.</span> <span class="toc-text">局部作用域和函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-JavaScript-%E5%AF%B9%E8%B1%A1"><span class="toc-number">16.</span> <span class="toc-text">创建 JavaScript 对象</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JavaScript-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">17.</span> <span class="toc-text">JavaScript 运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JavaScript-%E6%AF%94%E8%BE%83-%E5%92%8C-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">18.</span> <span class="toc-text">JavaScript 比较 和 逻辑运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JavaScript-if%E2%80%A6Else-%E8%AF%AD%E5%8F%A5"><span class="toc-number">19.</span> <span class="toc-text">JavaScript if…Else 语句</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JavaScript-switch-%E8%AF%AD%E5%8F%A5"><span class="toc-number">20.</span> <span class="toc-text">JavaScript switch 语句</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JavaScript-for-%E5%BE%AA%E7%8E%AF"><span class="toc-number">21.</span> <span class="toc-text">JavaScript for 循环</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JavaScript-while-%E5%BE%AA%E7%8E%AF"><span class="toc-number">22.</span> <span class="toc-text">JavaScript while 循环</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JavaScript-break-%E5%92%8C-continue-%E8%AF%AD%E5%8F%A5"><span class="toc-number">23.</span> <span class="toc-text">JavaScript break 和 continue 语句</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E8%B5%8B%E5%80%BC%E4%B9%8B"><span class="toc-number">24.</span> <span class="toc-text">复合赋值之 &#x2F;&#x3D;</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E7%82%B9%E5%8F%B7%E8%A1%A8%E7%A4%BA%E6%B3%95%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7-1"><span class="toc-number">25.</span> <span class="toc-text">通过点号表示法访问对象属性(1)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%8B%AC%E5%8F%B7%E8%A1%A8%E7%A4%BA%E6%B3%95%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7"><span class="toc-number">26.</span> <span class="toc-text">使用方括号表示法访问对象属性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%8F%98%E9%87%8F%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7"><span class="toc-number">27.</span> <span class="toc-text">通过变量访问对象属性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7"><span class="toc-number">28.</span> <span class="toc-text">更新对象属性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%99-JavaScript-%E5%AF%B9%E8%B1%A1%E6%B7%BB%E5%8A%A0%E6%96%B0%E5%B1%9E%E6%80%A7"><span class="toc-number">29.</span> <span class="toc-text">给 JavaScript 对象添加新属性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">30.</span> <span class="toc-text">删除对象的属性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E5%A4%8D%E6%9D%82%E5%AF%B9%E8%B1%A1"><span class="toc-number">31.</span> <span class="toc-text">操作复杂对象</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%B5%8C%E5%A5%97%E5%AF%B9%E8%B1%A1"><span class="toc-number">32.</span> <span class="toc-text">访问嵌套对象</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E9%9B%86%E5%90%88"><span class="toc-number">33.</span> <span class="toc-text">记录集合</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JavaScript-%E4%BD%BF%E7%94%A8%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C%E5%AF%B9%E8%B1%A1"><span class="toc-number">34.</span> <span class="toc-text">JavaScript 使用解构赋值操作对象</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%E4%BB%8E%E6%95%B0%E7%BB%84%E4%B8%AD%E5%88%86%E9%85%8D%E5%8F%98%E9%87%8F"><span class="toc-number">35.</span> <span class="toc-text">使用解构赋值从数组中分配变量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-rest-%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%84"><span class="toc-number">36.</span> <span class="toc-text">通过 rest 参数解构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JavaScript-%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%E5%9C%A8%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">37.</span> <span class="toc-text">JavaScript 解构赋值在函数参数中的基本用法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JavaScript-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">38.</span> <span class="toc-text">JavaScript 深拷贝与浅拷贝</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84-%E5%AF%B9%E8%B1%A1"><span class="toc-number">39.</span> <span class="toc-text">遍历数组&#x2F;对象</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JavaScript-%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8-%E7%B1%BB%E6%96%B9%E6%B3%95%E4%BB%A5%E5%8F%8A%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">40.</span> <span class="toc-text">JavaScript 类的使用-类方法以及构造函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JavaScript-%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8-getter-%E5%92%8C-setter-%E6%8E%A7%E5%88%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="toc-number">41.</span> <span class="toc-text">JavaScript 类的使用 - getter 和 setter 控制对象的访问</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JavaScript-%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8-%E7%BB%A7%E6%89%BF%EF%BC%9Aextends"><span class="toc-number">42.</span> <span class="toc-text">JavaScript 类的使用 - 继承：extends</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%94%A8-export-%E6%9D%A5%E9%87%8D%E7%94%A8%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">43.</span> <span class="toc-text">用 export 来重用代码块</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-import-%E5%A4%8D%E7%94%A8-JavaScript-%E4%BB%A3%E7%A0%81"><span class="toc-number">44.</span> <span class="toc-text">通过 import 复用 JavaScript 代码</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%94%A8-%E4%BB%8E%E6%96%87%E4%BB%B6%E4%B8%AD%E5%AF%BC%E5%85%A5%E6%89%80%E6%9C%89%E5%86%85%E5%AE%B9"><span class="toc-number">45.</span> <span class="toc-text">用 * 从文件中导入所有内容</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%94%A8-export-default-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E9%BB%98%E8%AE%A4%E5%AF%BC%E5%87%BA"><span class="toc-number">46.</span> <span class="toc-text">用 export default 创建一个默认导出</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5%E4%B8%80%E4%B8%AA%E9%BB%98%E8%AE%A4%E7%9A%84%E5%AF%BC%E5%87%BA"><span class="toc-number">47.</span> <span class="toc-text">导入一个默认的导出</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JavaScript-this%E6%8C%87%E5%90%91"><span class="toc-number">48.</span> <span class="toc-text">JavaScript this指向</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JavaScript-%E9%97%AD%E5%8C%85"><span class="toc-number">49.</span> <span class="toc-text">JavaScript 闭包</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JavaScript-bind%EF%BC%8Capply%EF%BC%8Ccall"><span class="toc-number">50.</span> <span class="toc-text">JavaScript bind，apply，call</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JavaScript-%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-number">51.</span> <span class="toc-text">JavaScript 回调函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA-JavaScript-Promise"><span class="toc-number">52.</span> <span class="toc-text">创建一个 JavaScript Promise</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-resolve-%E5%92%8C-reject-%E5%AE%8C%E6%88%90-Promise"><span class="toc-number">53.</span> <span class="toc-text">通过 resolve 和 reject 完成 Promise</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%94%A8-then-%E5%A4%84%E7%90%86-Promise-%E5%AE%8C%E6%88%90%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">54.</span> <span class="toc-text">用 then 处理 Promise 完成的情况</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-catch-%E5%A4%84%E7%90%86-Promise-%E5%A4%B1%E8%B4%A5%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">55.</span> <span class="toc-text">使用 catch 处理 Promise 失败的情况</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Promise-%E8%BF%9B%E9%98%B6"><span class="toc-number">56.</span> <span class="toc-text">Promise 进阶</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/07/16/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="基础数据结构"><img src="/img/index%20img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="基础数据结构"/></a><div class="content"><a class="title" href="/2024/07/16/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="基础数据结构">基础数据结构</a><time datetime="2024-07-16T09:20:39.960Z" title="发表于 2024-07-16 17:20:39">2024-07-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/16/React/" title="React"><img src="/img/index%20img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="React"/></a><div class="content"><a class="title" href="/2024/07/16/React/" title="React">React</a><time datetime="2024-07-16T03:41:05.708Z" title="发表于 2024-07-16 11:41:05">2024-07-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/15/jQuery%E6%A1%86%E6%9E%B6(DOM)/" title="jQuery框架(DOM)"><img src="/img/index%20img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="jQuery框架(DOM)"/></a><div class="content"><a class="title" href="/2024/07/15/jQuery%E6%A1%86%E6%9E%B6(DOM)/" title="jQuery框架(DOM)">jQuery框架(DOM)</a><time datetime="2024-07-15T15:53:52.355Z" title="发表于 2024-07-15 23:53:52">2024-07-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/13/JavaScript/" title="JavaScript"><img src="/img/index%20img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JavaScript"/></a><div class="content"><a class="title" href="/2024/07/13/JavaScript/" title="JavaScript">JavaScript</a><time datetime="2024-07-13T04:40:54.263Z" title="发表于 2024-07-13 12:40:54">2024-07-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/12/flexbox%E5%B8%83%E5%B1%80/" title="flexbox布局"><img src="/img/index%20img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="flexbox布局"/></a><div class="content"><a class="title" href="/2024/07/12/flexbox%E5%B8%83%E5%B1%80/" title="flexbox布局">flexbox布局</a><time datetime="2024-07-12T14:06:15.446Z" title="发表于 2024-07-12 22:06:15">2024-07-12</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/index%20img.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 晚风温柔苍生</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.14.0-b3"></script><script src="/js/main.js?v=4.14.0-b3"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.35/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = (ele) => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from(ele).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return
    
    codeMermaidEle.forEach(ele => {
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.innerHTML = `<pre class="mermaid-src" hidden>${ele.textContent}</pre>`
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (false) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@10.9.0/dist/mermaid.min.js').then(runMermaidFn)
  }
  
  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '6w3iig24wOf79eV25khBRlpG-MdYXbMMI',
      appKey: 'R3mFLiLWf7D8xSebljp3qDFJ',
      avatar: 'monsterid',
      serverURLs: 'https://6w3iig24.api.lncldglobal.com',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, {"placeholder":"ヾﾉ≧∀≦)o快来评论一下吧!","pageSize":10}))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await btf.getScript('https://cdn.jsdelivr.net/npm/valine@1.5.1/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !true) {
    if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.14.0-b3"></script></div></div></body></html>